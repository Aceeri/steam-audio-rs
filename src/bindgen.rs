/* automatically generated by rust-bindgen */

pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
/// \defgroup types Data Types
/// Common data types used throughout the Phonon API.
/// \{
pub type IPLvoid = ::std::os::raw::c_void;
pub type IPLint8 = ::std::os::raw::c_char;
pub type IPLuint8 = ::std::os::raw::c_uchar;
pub type IPLint16 = ::std::os::raw::c_short;
pub type IPLuint16 = ::std::os::raw::c_ushort;
pub type IPLint32 = ::std::os::raw::c_int;
pub type IPLuint32 = ::std::os::raw::c_uint;
pub type IPLint64 = ::std::os::raw::c_longlong;
pub type IPLuint64 = ::std::os::raw::c_ulonglong;
pub type IPLfloat32 = f32;
pub type IPLfloat64 = f64;
pub type IPLbyte = ::std::os::raw::c_uchar;
pub type IPLsize = usize;
pub type IPLstring = *mut ::std::os::raw::c_char;
/// An opaque handle to a Phonon API object. A variable of this type may not be cast to a pointer to any other
/// API type.
pub type IPLhandle = *mut ::std::os::raw::c_void;
pub const IPLbool_IPL_FALSE: IPLbool = 0;
pub const IPLbool_IPL_TRUE: IPLbool = 1;
pub type IPLbool = u32;
pub const IPLerror_IPL_STATUS_SUCCESS: IPLerror = 0;
pub const IPLerror_IPL_STATUS_FAILURE: IPLerror = 1;
pub const IPLerror_IPL_STATUS_OUTOFMEMORY: IPLerror = 2;
pub const IPLerror_IPL_STATUS_INITIALIZATION: IPLerror = 3;
pub type IPLerror = u32;
/// Prototype of a callback that logs a message generated by Phonon. This may be implemented in any suitable way,
/// such as appending to a log file, displaying a dialog box, etc. The default behavior is to print to \c stdout.
///
/// \param  message     The message to log.
pub type IPLLogFunction =
    ::std::option::Option<unsafe extern "C" fn(message: *mut ::std::os::raw::c_char) -> IPLvoid>;
/// Prototype of a callback that allocates memory. This is usually specified to let Phonon use a custom memory
/// allocator. The default behavior is to use the OS-dependent aligned version of \c malloc.
///
/// \param  size        The number of bytes to allocate.
/// \param  alignment   The alignment (in bytes) of the start address of the allocated memory.
///
/// \return Pointer to the allocated block of memory, or \c NULL if allocation failed.
pub type IPLAllocateFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: IPLsize,
                         arg2: IPLsize)
                         -> *mut IPLvoid,
>;
/// Prototype of a callback that frees a block of memory. This is usually specified when using a custom memory
/// allocator with Phonon. The default behavior is to use the OS-dependent aligned version of \c free.
///
/// \param  memoryBlock Pointer to the block of memory.
pub type IPLFreeFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut IPLvoid) -> IPLvoid,
>;
extern "C" {
    /// Creates a Context object. A Context object must be created before creating any other API objects.
    ///
    /// \param  logCallback         Callback for logging messages. Can be NULL.
    /// \param  allocateCallback    Callback for allocating memory. Can be NULL.
    /// \param  freeCallback        Callback for freeing memory. Can be NULL.
    /// \param  context             [out] Handle to the created Context object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateContext(
        logCallback: IPLLogFunction,
        allocateCallback: IPLAllocateFunction,
        freeCallback: IPLFreeFunction,
        context: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Context object. If any other API objects are still referencing the Context object, it will not be
    /// destroyed; destruction occurs when the Context object's reference count reaches zero.
    ///
    /// \param  context             [in, out] Address of a handle to the Context object to destroy.
    pub fn iplDestroyContext(context: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Performs last-minute cleanup and finalization. This function must be the last API function to be called before
    /// your application exits.
    pub fn iplCleanup() -> IPLvoid;
}
/// A point or vector in 3D space. Phonon uses a right-handed coordinate system, with the positive x-axis pointing
/// right, the positive y-axis pointing up, and the negative z-axis pointing ahead. Position and direction data
/// obtained from a game engine or audio engine must be properly transformed before being passed to any Phonon API
/// function.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLVector3 {
    /// < The x-coordinate.
    pub x: IPLfloat32,
    /// < The y-coordinate.
    pub y: IPLfloat32,
    /// < The z-coordinate.
    pub z: IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLVector3() {
    assert_eq!(
        ::std::mem::size_of::<IPLVector3>(),
        12usize,
        concat!("Size of: ", stringify!(IPLVector3))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLVector3>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLVector3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLVector3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLVector3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLVector3>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLVector3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLVector3>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLVector3),
            "::",
            stringify!(z)
        )
    );
}
/// A unit-length quaternion. Quaternions are used to represent a rotation or orientation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLQuaternion {
    /// < The x-coordinate of the vector part.
    pub x: IPLfloat32,
    /// < The y-coordinate of the vector part.
    pub y: IPLfloat32,
    /// < The z-coordinate of the vector part.
    pub z: IPLfloat32,
    /// < The scalar part.
    pub w: IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<IPLQuaternion>(),
        16usize,
        concat!("Size of: ", stringify!(IPLQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLQuaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLQuaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLQuaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLQuaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLQuaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLQuaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLQuaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLQuaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLQuaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLQuaternion),
            "::",
            stringify!(w)
        )
    );
}
/// An axis-aligned box. Axis-aligned boxes are used to specify a volume of 3D space.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBox {
    /// < The minimum coordinates of any vertex.
    pub minCoordinates: IPLVector3,
    /// < The maximum coordinates of any vertex.
    pub maxCoordinates: IPLVector3,
}
#[test]
fn bindgen_test_layout_IPLBox() {
    assert_eq!(
        ::std::mem::size_of::<IPLBox>(),
        24usize,
        concat!("Size of: ", stringify!(IPLBox))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLBox>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBox>())).minCoordinates as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBox),
            "::",
            stringify!(minCoordinates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBox>())).maxCoordinates as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBox),
            "::",
            stringify!(maxCoordinates)
        )
    );
}
/// An oriented box. Oriented boxes are used to specify a volume of 3D space.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLOrientedBox {
    /// < The center of the box.
    pub mCenter: IPLVector3,
    /// < The extents of the box.
    pub mExtents: IPLVector3,
    /// < The rotation of the box.
    pub mRotation: IPLQuaternion,
}
#[test]
fn bindgen_test_layout_IPLOrientedBox() {
    assert_eq!(
        ::std::mem::size_of::<IPLOrientedBox>(),
        40usize,
        concat!("Size of: ", stringify!(IPLOrientedBox))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLOrientedBox>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLOrientedBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLOrientedBox>())).mCenter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLOrientedBox),
            "::",
            stringify!(mCenter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLOrientedBox>())).mExtents as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLOrientedBox),
            "::",
            stringify!(mExtents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLOrientedBox>())).mRotation as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLOrientedBox),
            "::",
            stringify!(mRotation)
        )
    );
}
/// A sphere. Spheres are used to define a region of influence around a point.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSphere {
    /// < The center.
    pub center: IPLVector3,
    /// < The radius.
    pub radius: IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLSphere() {
    assert_eq!(
        ::std::mem::size_of::<IPLSphere>(),
        16usize,
        concat!("Size of: ", stringify!(IPLSphere))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLSphere>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLSphere))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSphere>())).center as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSphere),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSphere>())).radius as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSphere),
            "::",
            stringify!(radius)
        )
    );
}
extern "C" {
    /// Calculates the relative direction from the listener to a sound source. The returned direction
    /// vector is expressed in the listener's coordinate system.
    ///
    /// \param  sourcePosition      World-space coordinates of the source.
    /// \param  listenerPosition    World-space coordinates of the listener.
    /// \param  listenerAhead       World-space unit-length vector pointing ahead relative to the listener.
    /// \param  listenerUp          World-space unit-length vector pointing up relative to the listener.
    ///
    /// \return A unit-length vector in the listener's coordinate space, pointing from the listener to the source.
    pub fn iplCalculateRelativeDirection(
        sourcePosition: IPLVector3,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
    ) -> IPLVector3;
}
pub const IPLComputeDeviceType_IPL_COMPUTEDEVICE_CPU: IPLComputeDeviceType = 0;
pub const IPLComputeDeviceType_IPL_COMPUTEDEVICE_GPU: IPLComputeDeviceType = 1;
pub const IPLComputeDeviceType_IPL_COMPUTEDEVICE_ANY: IPLComputeDeviceType = 2;
pub type IPLComputeDeviceType = u32;
/// Specifies constraints on the type of OpenCL device to create. This information is intended to be passed to
/// \c iplCreateComputeDevice.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLComputeDeviceFilter {
    /// < The type of device to use.
    pub type_: IPLComputeDeviceType,
    /// < Whether the device must support AMD TrueAudio Next.
    pub requiresTrueAudioNext: IPLbool,
    /// < The minimum number of CUs that should be possible to
    /// reserve on the device, for TrueAudio Next.
    pub minReservableCUs: IPLint32,
    /// < The maximum number of CUs that the application needs to
    /// reserve on the device, for TrueAudio Next.
    pub maxCUsToReserve: IPLint32,
}
#[test]
fn bindgen_test_layout_IPLComputeDeviceFilter() {
    assert_eq!(
        ::std::mem::size_of::<IPLComputeDeviceFilter>(),
        16usize,
        concat!("Size of: ", stringify!(IPLComputeDeviceFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLComputeDeviceFilter>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLComputeDeviceFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLComputeDeviceFilter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComputeDeviceFilter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLComputeDeviceFilter>())).requiresTrueAudioNext as *const _ as
                usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComputeDeviceFilter),
            "::",
            stringify!(requiresTrueAudioNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLComputeDeviceFilter>())).minReservableCUs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComputeDeviceFilter),
            "::",
            stringify!(minReservableCUs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLComputeDeviceFilter>())).maxCUsToReserve as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComputeDeviceFilter),
            "::",
            stringify!(maxCUsToReserve)
        )
    );
}
extern "C" {
    /// Creates a Compute Device object. The same Compute Device must be used by the game engine and audio engine
    /// parts of the Phonon integration. Depending on the OpenCL driver and device, this function may take some
    /// time to execute, so do not call it from performance-sensitive code.
    ///
    /// \param  context         The Context object used by the game engine.
    /// \param	deviceFilter    Constraints on the type of device to create.
    /// \param  device          [out] Handle to the created Compute Device object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateComputeDevice(
        context: IPLhandle,
        deviceFilter: IPLComputeDeviceFilter,
        device: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Compute Device object. If any other API objects are still referencing the Compute Device object,
    /// it will not be destroyed; destruction occurs when the object's reference count reaches zero.
    ///
    /// \param  device  [in, out] Address of a handle to the Compute Device object to destroy.
    pub fn iplDestroyComputeDevice(device: *mut IPLhandle) -> IPLvoid;
}
pub const IPLSceneType_IPL_SCENETYPE_PHONON: IPLSceneType = 0;
pub const IPLSceneType_IPL_SCENETYPE_EMBREE: IPLSceneType = 1;
pub const IPLSceneType_IPL_SCENETYPE_FIRERAYS: IPLSceneType = 2;
pub const IPLSceneType_IPL_SCENETYPE_CUSTOM: IPLSceneType = 3;
pub type IPLSceneType = u32;
pub const IPLSimulationType_IPL_SIMTYPE_REALTIME: IPLSimulationType = 0;
pub const IPLSimulationType_IPL_SIMTYPE_BAKED: IPLSimulationType = 1;
pub type IPLSimulationType = u32;
/// Configures the complexity of the simulation. You can fine-tune these values to arrive at a suitable
/// balance between performance, memory usage, and acoustic detail.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSimulationSettings {
    /// < The ray tracer to use for simulation. \see IPLSceneType.
    pub sceneType: IPLSceneType,
    /// < The number of rays to trace from the listener. Increasing this
    /// number increases the accuracy of the simulation, but also
    /// increases CPU usage. Any positive integer may be specified,
    /// but typical values are in the range of 1024 to 131072.
    pub numRays: IPLint32,
    /// < The number of directions to consider when a ray bounces off
    /// a diffuse (or partly diffuse) surface. Increasing this number
    /// increases the accuracy of diffuse reflections, and does not
    /// significantly impact CPU usage. Any positive integer may be
    /// specified, but typical values are in the range of 32 to 4096.
    pub numDiffuseSamples: IPLint32,
    /// < The maximum number of times any ray can bounce within the scene.
    /// Increasing this number allows the simulation to more accurately
    /// model reverberant spaces, at the cost of increased CPU usage.
    /// Any positive integer may be specified, but typical values are
    /// in the range of 1 to 32.
    pub numBounces: IPLint32,
    /// < The time delay between a sound being emitted and the last
    /// audible reflection. Echoes and reverberation longer than this
    /// amount will not be modeled by the simulation. Any positive
    /// number may be specified, but typical values are in the range
    /// of 0.5 to 4.0.
    pub irDuration: IPLfloat32,
    /// < The amount of directional detail in the simulation results.
    /// Phonon encodes the simulation results using Ambisonics.
    /// Increasing this number increases the amount of directional
    /// detail in the simulated acoustics, but at the cost of
    /// increased CPU usage and memory consumption. Supported values
    /// are between 0 and 3.
    pub ambisonicsOrder: IPLint32,
    /// < The maximum number of sound sources that can be simulated
    /// and rendered using a Convolution Effect object at any point
    /// in time. If you attempt to create more than this many
    /// Convolution Effect objects, creation will fail. Increasing
    /// this number allows more sound sources to be rendered with
    /// sound propagation effects, but at the cost of increased
    /// memory consumption.
    pub maxConvolutionSources: IPLint32,
}
#[test]
fn bindgen_test_layout_IPLSimulationSettings() {
    assert_eq!(
        ::std::mem::size_of::<IPLSimulationSettings>(),
        28usize,
        concat!("Size of: ", stringify!(IPLSimulationSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLSimulationSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLSimulationSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSimulationSettings>())).sceneType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(sceneType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSimulationSettings>())).numRays as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(numRays)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLSimulationSettings>())).numDiffuseSamples as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(numDiffuseSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSimulationSettings>())).numBounces as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(numBounces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLSimulationSettings>())).irDuration as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(irDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLSimulationSettings>())).ambisonicsOrder as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(ambisonicsOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLSimulationSettings>())).maxConvolutionSources as *const _ as
                usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLSimulationSettings),
            "::",
            stringify!(maxConvolutionSources)
        )
    );
}
/// A triangle in 3D space. Triangles are specified by their three vertices, which are in turn specified using
/// indices into a vertex array. See iplSetStaticMeshVertices for how to specify the vertex array. Phonon uses
/// a counter-clockwise winding order. This means that when looking at the triangle such that the normal is
/// pointing towards you, the vertices are specified in counter-clockwise order.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLTriangle {
    /// < Indices of the three vertices of this triangle. Each triangle must be specified
    /// using three vertices; triangle strip or fan representations are not supported.
    pub indices: [IPLint32; 3usize],
}
#[test]
fn bindgen_test_layout_IPLTriangle() {
    assert_eq!(
        ::std::mem::size_of::<IPLTriangle>(),
        12usize,
        concat!("Size of: ", stringify!(IPLTriangle))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLTriangle>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLTriangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLTriangle>())).indices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLTriangle),
            "::",
            stringify!(indices)
        )
    );
}
/// The acoustic properties of a surface. You can specify the acoustic material properties of each triangle,
/// although typically many triangles will share a common material. The acoustic material properties are specified
/// for three frequency bands with center frequencies of 400 Hz, 2.5 KHz, and 15 KHz.
///
/// Below are the acoustic material properties for a few standard materials.
///
/// ```cpp
/// {"generic",{0.10f,0.20f,0.30f,0.05f,0.100f,0.050f,0.030f}}
/// {"brick",{0.03f,0.04f,0.07f,0.05f,0.015f,0.015f,0.015f}}
/// {"concrete",{0.05f,0.07f,0.08f,0.05f,0.015f,0.002f,0.001f}}
/// {"ceramic",{0.01f,0.02f,0.02f,0.05f,0.060f,0.044f,0.011f}}
/// {"gravel",{0.60f,0.70f,0.80f,0.05f,0.031f,0.012f,0.008f}},
/// {"carpet",{0.24f,0.69f,0.73f,0.05f,0.020f,0.005f,0.003f}}
/// {"glass",{0.06f,0.03f,0.02f,0.05f,0.060f,0.044f,0.011f}}
/// {"plaster",{0.12f,0.06f,0.04f,0.05f,0.056f,0.056f,0.004f}}
/// {"wood",{0.11f,0.07f,0.06f,0.05f,0.070f,0.014f,0.005f}}
/// {"metal",{0.20f,0.07f,0.06f,0.05f,0.200f,0.025f,0.010f}}
/// {"rock",{0.13f,0.20f,0.24f,0.05f,0.015f,0.002f,0.001f}}
/// ```
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLMaterial {
    /// < Fraction of sound energy absorbed at low frequencies. Between 0.0 and
    /// 1.0.
    pub lowFreqAbsorption: IPLfloat32,
    /// < Fraction of sound energy absorbed at middle frequencies. Between 0.0
    /// and 1.0.
    pub midFreqAbsorption: IPLfloat32,
    /// < Fraction of sound energy absorbed at high frequencies. Between 0.0 and
    /// 1.0.
    pub highFreqAbsorption: IPLfloat32,
    /// < Fraction of sound energy that is scattered in a random direction when
    /// it reaches the surface. Between 0.0 and 1.0. A value of 0.0 describes
    /// a smooth surface with mirror-like reflection properties; a value of 1.0
    /// describes rough surface with diffuse reflection properties.
    pub scattering: IPLfloat32,
    /// < Fraction of sound energy transmitted through at low frequencies.
    /// Between 0.0 and 1.0.
    /// <b>Used only for direct sound occlusion calculations</b>.
    pub lowFreqTransmission: IPLfloat32,
    /// < Fraction of sound energy transmitted through at middle frequencies.
    /// Between 0.0 and 1.0.
    /// <b>Used only for direct sound occlusion calculations</b>.
    pub midFreqTransmission: IPLfloat32,
    /// < Fraction of sound energy transmitted through at high frequencies.
    /// Between 0.0 and 1.0.
    /// <b>Used only for direct sound occlusion calculations</b>.
    pub highFreqTransmission: IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLMaterial() {
    assert_eq!(
        ::std::mem::size_of::<IPLMaterial>(),
        28usize,
        concat!("Size of: ", stringify!(IPLMaterial))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLMaterial>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLMaterial))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).lowFreqAbsorption as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(lowFreqAbsorption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).midFreqAbsorption as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(midFreqAbsorption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).highFreqAbsorption as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(highFreqAbsorption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).scattering as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(scattering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).lowFreqTransmission as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(lowFreqTransmission)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).midFreqTransmission as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(midFreqTransmission)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLMaterial>())).highFreqTransmission as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLMaterial),
            "::",
            stringify!(highFreqTransmission)
        )
    );
}
/// A callback that is called to update the application on the progress of the iplLoadScene function. You can
/// use this to provide the user with visual feedback, like a progress bar.
///
/// \param  progress    Fraction of the loading process that has been completed, between 0.0 and 1.0.
pub type IPLLoadSceneProgressCallback =
    ::std::option::Option<unsafe extern "C" fn(progress: IPLfloat32)>;
/// A callback that is called to update the application on the progress of the iplFinalizeScene function. You can
/// use this to provide the user with visual feedback, like a progress bar.
///
/// \param  progress    Fraction of the finalization process that has been completed, between 0.0 and 1.0.
pub type IPLFinalizeSceneProgressCallback =
    ::std::option::Option<unsafe extern "C" fn(progress: IPLfloat32)>;
/// A callback that is called to calculate the closest hit along a ray. Strictly speaking, the intersection is
/// calculated with a ray _interval_ (equivalent to a line segment). Any ray interval may have multiple points
/// of intersection with scene geometry; this function must return information about the point of intersection that
/// is closest to the ray's origin.
///
/// \param  origin              Array containing the x, y, z coordinates (in that order) of the ray's origin.
/// \param  direction           Array containing the x, y, z coordinates (in that order) of a unit-length vector
/// along the ray's direction.
/// \param  minDistance         The minimum distance from the origin at which an intersection may occur for it
/// to be considered. This function must not return any intersections closer to the
/// origin than this value.
/// \param  maxDistance         The maximum distance from the origin at which an intersection may occur for it
/// to be considered. This function must not return any intersections farther from
/// the origin than this value.
/// \param  hitDistance         [out] Distance between the origin and the closest intersection point on the ray.
/// \param  hitNormal           [out] Array containing the x, y, z coordinates (in that order) of the unit-length
/// surface normal of the geometry at the closest intersection point.
/// \param  hitMaterial         [out] Address of a pointer to the material properties of the surface at the closest
/// intersection point. The array contains the low-, mid-, and high-frequency
/// absorption coefficients, the scattering coefficient, and the low-, mid-, and
/// high-frequency transmission coefficients, in that order.
/// \param  userData            Pointer a block of memory containing arbitrary data, specified during the call to
/// \c ::iplSetRayTracerCallbacks.
pub type IPLClosestHitCallback =
    ::std::option::Option<
        unsafe extern "C" fn(origin: *const IPLfloat32,
                             direction: *const IPLfloat32,
                             minDistance: IPLfloat32,
                             maxDistance: IPLfloat32,
                             hitDistance: *mut IPLfloat32,
                             hitNormal: *mut IPLfloat32,
                             hitMaterial: *mut *mut IPLMaterial,
                             userData: *mut IPLvoid),
    >;
/// A callback that is called to calculate whether a ray hits any geometry. Strictly speaking, the function
/// looks for any intersection with a ray _interval_ (equivalent to a line segment).
///
/// \param  origin              Array containing the x, y, z coordinates (in that order) of the ray's origin.
/// \param  direction           Array containing the x, y, z coordinates (in that order) of a unit-length vector
/// along the ray's direction.
/// \param  minDistance         The minimum distance from the origin at which an intersection may occur for it
/// to be considered.
/// \param  maxDistance         The maximum distance from the origin at which an intersection may occur for it
/// to be considered.
/// \param  hitExists           [out] An integer indicating whether the ray intersects any geometry. A value of 0
/// indicates no intersection, 1 indicates that an intersection exists.
/// \param  userData            Pointer a block of memory containing arbitrary data, specified during the call to
/// \c ::iplSetRayTracerCallbacks.
pub type IPLAnyHitCallback =
    ::std::option::Option<
        unsafe extern "C" fn(origin: *const IPLfloat32,
                             direction: *const IPLfloat32,
                             minDistance: IPLfloat32,
                             maxDistance: IPLfloat32,
                             hitExists: *mut IPLint32,
                             userData: *mut IPLvoid),
    >;
extern "C" {
    /// Creates a Scene object. A Scene object does not store any geometry information on its own; for that you
    /// need to create one or more Static Mesh objects and add them to the Scene object. The Scene object
    /// does contain an array of materials; all triangles in all Static Mesh objects refer to this array in order
    /// to specify their material properties.
    ///
    /// \param  context             The Context object used by the game engine.
    /// \param  computeDevice       Handle to a Compute Device object. Only required if using Radeon Rays for
    /// ray tracing, may be \c NULL otherwise.
    /// \param  simulationSettings  The settings to use for simulation.
    /// \param  numMaterials        The number of materials that are used to describe the various surfaces in
    /// the scene. Materials may not be added or removed once the Scene object is
    /// created.
    /// \param  scene               [out] Handle to the created Scene object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateScene(
        context: IPLhandle,
        computeDevice: IPLhandle,
        simulationSettings: IPLSimulationSettings,
        numMaterials: IPLint32,
        scene: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Scene object. If any other API objects are still referencing the Scene object, it will not be
    /// destroyed; destruction occurs when the object's reference count reaches zero.
    ///
    /// \param  scene               [in, out] Address of a handle to the Scene object to destroy.
    pub fn iplDestroyScene(scene: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Specifies a single material used by a Scene object. All materials must be completely specified before
    /// simulation occurs, otherwise simulation results will be incorrect.
    ///
    /// \param  scene               Handle to the Scene object.
    /// \param  materialIndex       Index of the material to set. Between 0 and N-1, where N is the value of
    /// \c numMaterials passed to \c ::iplCreateScene.
    /// \param  material            The material properties to use.
    pub fn iplSetSceneMaterial(
        scene: IPLhandle,
        materialIndex: IPLint32,
        material: IPLMaterial,
    ) -> IPLvoid;
}
extern "C" {
    /// Specifies callbacks that allow a Scene object to call into a user-specified custom ray tracer. This function
    /// should only be called if using a custom ray tracer, or else undefined behavior will occur. When using a custom
    /// ray tracer, this function must be called before any simulation occurs, otherwise undefined behavior will
    /// occur.
    ///
    /// \param  scene               Handle to the Scene object.
    /// \param  closestHitCallback  Pointer to a function that returns the closest hit along a ray.
    /// \param  anyHitCallback      Pointer to a function that returns whether a ray hits anything.
    /// \param  userData            Pointer to a block of memory containing arbitrary data for use
    /// by the closest hit and any hit callbacks.
    pub fn iplSetRayTracerCallbacks(
        scene: IPLhandle,
        closestHitCallback: IPLClosestHitCallback,
        anyHitCallback: IPLAnyHitCallback,
        userData: *mut IPLvoid,
    ) -> IPLvoid;
}
extern "C" {
    /// Creates a Static Mesh object. A Static Mesh object represents a triangle mesh that does not change after it
    /// is created. A Static Mesh object also contains a mapping between each of its triangles and their acoustic
    /// material properties. Static Mesh objects should be used for scene geometry that is guaranteed to never change,
    /// such as rooms, buildings, or triangulated terrain. A Scene object may contain multiple Static Mesh objects,
    /// although typically one is sufficient.
    ///
    /// \param  scene               Handle to the Scene object to which to add the Static Mesh object.
    /// \param  numVertices         Number of vertices in the triangle mesh.
    /// \param  numTriangles        Number of triangles in the triangle mesh.
    /// \param  staticMesh          [out] Handle to the created Static Mesh object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateStaticMesh(
        scene: IPLhandle,
        numVertices: IPLint32,
        numTriangles: IPLint32,
        staticMesh: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Static Mesh object. If any other API objects are still referencing the Static Mesh object, it will
    /// not be destroyed; destruction occurs when the object's reference count reaches zero. Since the Scene object
    /// maintains an internal reference to the Static Mesh object, you may call this function at any point after
    /// fully specifying the Static Mesh object using \c ::iplSetStaticMeshVertices, \c ::iplSetStaticMeshTriangles,
    /// and \c ::iplSetStaticMeshMaterials.
    ///
    /// \param  staticMesh          [in, out] Address of a handle to the Static Mesh object to destroy.
    pub fn iplDestroyStaticMesh(staticMesh: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Specifies the vertices of a Static Mesh object. All vertices must be converted from the game engine's
    /// coordinate system to Phonon's coordinate system before being passed to this function.
    ///
    /// \param  scene               Handle to the Scene object containing the Static Mesh object.
    /// \param  staticMesh          Handle to the Static Mesh object.
    /// \param  vertices            Array containing the coordinates of all vertices in the Static Mesh object.
    /// The number of \c IPLVector3 objects in the array must be equal to the value of
    /// \c numVertices passed to \c ::iplCreateStaticMesh.
    pub fn iplSetStaticMeshVertices(
        scene: IPLhandle,
        staticMesh: IPLhandle,
        vertices: *mut IPLVector3,
    ) -> IPLvoid;
}
extern "C" {
    /// Specifies the triangles of a Static Mesh object. Triangle indices passed using this function refer to
    /// the vertex array passed using \c ::iplSetStaticMeshVertices.
    ///
    /// \param  scene               Handle to the Scene object containing the Static Mesh object.
    /// \param  staticMesh          Handle to the Static Mesh object.
    /// \param  triangles           Array containing all triangles in the Static Mesh object. The number of
    /// \c IPLTriangle objects in the array must be equal to the value of
    /// \c numTriangles passed to \c ::iplCreateStaticMesh.
    pub fn iplSetStaticMeshTriangles(
        scene: IPLhandle,
        staticMesh: IPLhandle,
        triangles: *mut IPLTriangle,
    ) -> IPLvoid;
}
extern "C" {
    /// Specifies the materials associated with each triangle in a Static Mesh object. Material indices passed
    /// using this function refer to the array containing material data passed to \c ::iplSetSceneMaterial.
    ///
    /// \param  scene               Handle to the Scene object containing the Static Mesh object.
    /// \param  staticMesh          Handle to the Static Mesh object.
    /// \param  materialIndices     Array containing material indices for all triangles in the Static Mesh object.
    /// The number of material indices in the array must be equal to the value of
    /// \c numTriangles passed to \c ::iplCreateStaticMesh.
    pub fn iplSetStaticMeshMaterials(
        scene: IPLhandle,
        staticMesh: IPLhandle,
        materialIndices: *mut IPLint32,
    ) -> IPLvoid;
}
extern "C" {
    /// Finalizes a scene and builds internal data structures. Once this function is called, you may not modify
    /// the Scene object or any Static Mesh objects it contains in any way. This function results in various
    /// internal data structures being generated; if using Radeon Rays, it results in scene data being uploaded
    /// to the GPU. This is a time-consuming, blocking call, so do not call it from performance-sensitive code.
    ///
    /// \param  scene               Handle to the Scene object.
    /// \param  progressCallback    Pointer to a function that reports the percentage of this function's work
    /// that has been completed. May be \c NULL.
    pub fn iplFinalizeScene(
        scene: IPLhandle,
        progressCallback: IPLFinalizeSceneProgressCallback,
    ) -> IPLvoid;
}
extern "C" {
    /// Serializes a Scene object to a byte array. The \c ::iplFinalizeScene function must have been called on
    /// the Scene object before calling this function. This function can only be called on a Scene object that
    /// has been created using the Phonon built-in ray tracer.
    ///
    /// \param  scene               Handle to the Scene object.
    /// \param  data                [out] Byte array into which the Scene object will be serialized. It is the
    /// caller's responsibility to manage memory for this array. The array must be large
    /// enough to hold all the data in the Scene object. May be \c NULL, in which case
    /// no data is returned; this is useful when finding out the size of the data stored
    /// in the Scene object.
    pub fn iplSaveFinalizedScene(scene: IPLhandle, data: *mut IPLbyte) -> IPLint32;
}
extern "C" {
    /// Creates a Scene object based on data stored in a byte array. After this function is called, it is not
    /// necessary to call \c ::iplFinalizeScene on the resulting Scene object.
    ///
    /// \param  context             The Context object used by the game engine.
    /// \param  simulationSettings  The settings to use for the simulation. This must exactly match the settings
    /// that were used to create the original Scene object that was passed to
    /// \c ::iplSaveFinalizedScene, except for the \c sceneType and \c simulationType
    /// data members. This allows you to use the same file to create a Scene object
    /// that uses any ray tracer you prefer.
    /// \param  data                Byte array containing the serialized representation of the Scene object. Must
    /// not be \c NULL.
    /// \param  size                Size (in bytes) of the serialized data.
    /// \param  computeDevice       Handle to a Compute Device object. Only required if using Radeon Rays for
    /// ray tracing, may be \c NULL otherwise.
    /// \param  progressCallback    Pointer to a function that reports the percentage of this function's work
    /// that has been completed. May be \c NULL.
    /// \param  scene               [out] Handle to the created Scene object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplLoadFinalizedScene(
        context: IPLhandle,
        simulationSettings: IPLSimulationSettings,
        data: *mut IPLbyte,
        size: IPLint32,
        computeDevice: IPLhandle,
        progressCallback: IPLLoadSceneProgressCallback,
        scene: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Saves a Scene object to an OBJ file. An OBJ file is a widely-supported 3D model file format, that can be
    /// displayed using a variety of software on most PC platforms. The OBJ file generated by this function can be
    /// useful for detecting problems that occur when exporting scene data from the game engine to Phonon. The
    /// \c ::iplFinalizeScene function must have been called on the Scene object before calling this function.
    /// This function can only be called on a Scene object that has been created using the Phonon built-in ray tracer.
    ///
    /// \param  scene               Handle to the Scene object.
    /// \param  fileBaseName        Absolute or relative path to the OBJ file to generate.
    pub fn iplDumpSceneToObjFile(scene: IPLhandle, fileBaseName: IPLstring) -> IPLvoid;
}
extern "C" {
    /// Creates an Environment object. It is necessary to call this function even if you are not using the sound
    /// propagation features of Phonon.
    ///
    /// \param  context             The Context object used by the game engine.
    /// \param  computeDevice       Handle to a Compute Device object. Only required if using Radeon Rays for
    /// ray tracing, or if using TrueAudio Next for convolution, may be \c NULL otherwise.
    /// \param  simulationSettings  The settings to use for simulation. This must be the same settings passed to
    /// \c ::iplCreateScene or \c ::iplLoadFinalizedScene, whichever was used to create
    /// the Scene object passed in the \c scene parameter to this function.
    /// \param  scene               The Scene object. If created using \c ::iplCreateScene, then \c ::iplFinalizeScene
    /// must have been called on the Scene object before passing it to this function.
    /// May be \c NULL, in which case only direct sound will be simulated, without
    /// occlusion or any other indirect sound propagation.
    /// \param  probeManager        The Probe Manager object. May be \c NULL if not using baked data.
    /// \param  environment         [out] Handle to the created Environment object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateEnvironment(
        context: IPLhandle,
        computeDevice: IPLhandle,
        simulationSettings: IPLSimulationSettings,
        scene: IPLhandle,
        probeManager: IPLhandle,
        environment: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Environment object. If any other API objects are still referencing the Environment object, it will
    /// not be destroyed; destruction occurs when the object's reference count reaches zero.
    ///
    /// \param  environment         [in, out] Address of a handle to the Environment object to destroy.
    pub fn iplDestroyEnvironment(environment: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Sets the number of bounces to use for real-time simulations that use an Environment object. Calling this
    /// function overrides the value of \c bounces set on the \c IPLSimulationSettings structure passed when
    /// calling \c ::iplCreateEnvironment to create this Environment object.
    ///
    /// \param  environment         Handle to an Environment object.
    /// \param  numBounces          The number of bounces to use for all subsequent simulations in the Environment.
    pub fn iplSetNumBounces(environment: IPLhandle, numBounces: IPLint32) -> IPLvoid;
}
pub const IPLConvolutionType_IPL_CONVOLUTIONTYPE_PHONON: IPLConvolutionType = 0;
pub const IPLConvolutionType_IPL_CONVOLUTIONTYPE_TRUEAUDIONEXT: IPLConvolutionType = 1;
pub type IPLConvolutionType = u32;
/// Describes various properties of the audio processing pipeline. Many Phonon API objects that are used by the
/// audio engine need to know how the audio processing pipeline (i.e., your audio engine) applies DSP effects to
/// audio data. This structure describes the key parameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLRenderingSettings {
    /// < The sampling rate (in Hz) of any audio to be processed by Phonon.
    /// All audio that is passed to Phonon must use the same sampling
    /// rate.** Phonon will output audio at the same sampling rate as its
    /// input; no sampling rate conversion will be performed. Supported
    /// sampling rates are 24000 Hz, 44100 Hz, and 48000 Hz.
    pub samplingRate: IPLint32,
    /// < The number of samples in a single frame of audio. The value of
    /// this parameter should be obtained from your audio engine.
    pub frameSize: IPLint32,
    /// < The convolution algorithm to use for any Convolution Effect
    /// objects created for this audio processing pipeline.
    pub convolutionType: IPLConvolutionType,
}
#[test]
fn bindgen_test_layout_IPLRenderingSettings() {
    assert_eq!(
        ::std::mem::size_of::<IPLRenderingSettings>(),
        12usize,
        concat!("Size of: ", stringify!(IPLRenderingSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLRenderingSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLRenderingSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLRenderingSettings>())).samplingRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLRenderingSettings),
            "::",
            stringify!(samplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLRenderingSettings>())).frameSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLRenderingSettings),
            "::",
            stringify!(frameSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLRenderingSettings>())).convolutionType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLRenderingSettings),
            "::",
            stringify!(convolutionType)
        )
    );
}
pub const IPLChannelLayoutType_IPL_CHANNELLAYOUTTYPE_SPEAKERS: IPLChannelLayoutType = 0;
pub const IPLChannelLayoutType_IPL_CHANNELLAYOUTTYPE_AMBISONICS: IPLChannelLayoutType = 1;
pub type IPLChannelLayoutType = u32;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_MONO: IPLChannelLayout = 0;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_STEREO: IPLChannelLayout = 1;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_QUADRAPHONIC: IPLChannelLayout = 2;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_FIVEPOINTONE: IPLChannelLayout = 3;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_SEVENPOINTONE: IPLChannelLayout = 4;
pub const IPLChannelLayout_IPL_CHANNELLAYOUT_CUSTOM: IPLChannelLayout = 5;
pub type IPLChannelLayout = u32;
pub const IPLAmbisonicsOrdering_IPL_AMBISONICSORDERING_FURSEMALHAM: IPLAmbisonicsOrdering = 0;
pub const IPLAmbisonicsOrdering_IPL_AMBISONICSORDERING_ACN: IPLAmbisonicsOrdering = 1;
pub type IPLAmbisonicsOrdering = u32;
pub const IPLAmbisonicsNormalization_IPL_AMBISONICSNORMALIZATION_FURSEMALHAM : IPLAmbisonicsNormalization = 0 ;
pub const IPLAmbisonicsNormalization_IPL_AMBISONICSNORMALIZATION_SN3D : IPLAmbisonicsNormalization = 1 ;
pub const IPLAmbisonicsNormalization_IPL_AMBISONICSNORMALIZATION_N3D: IPLAmbisonicsNormalization =
    2;
pub type IPLAmbisonicsNormalization = u32;
pub const IPLChannelOrder_IPL_CHANNELORDER_INTERLEAVED: IPLChannelOrder = 0;
pub const IPLChannelOrder_IPL_CHANNELORDER_DEINTERLEAVED: IPLChannelOrder = 1;
pub type IPLChannelOrder = u32;
/// The format of an audio buffer. Whenever you pass audio data to or from Phonon, you must describe the format in
/// which the audio is encoded. **Phonon only supports uncompressed PCM wave data, stored in 32-bit floating point
/// format**. However, Phonon supports many different multi-channel and Ambisonics formats, and the
/// \c IPLAudioFormat tells Phonon how to interpret a buffer of audio data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAudioFormat {
    /// < Indicates whether or not the audio should be
    /// interpreted as Ambisonics data.
    pub channelLayoutType: IPLChannelLayoutType,
    /// < Specifies the speaker configuration used for
    /// multi-channel, speaker-based audio data. Ignored
    /// if \c channelLayoutType is
    /// \c ::IPL_CHANNELLAYOUTTYPE_AMBISONICS.
    pub channelLayout: IPLChannelLayout,
    /// < The number of channels in the audio data. Only
    /// used if \c channelLayoutType is
    /// \c ::IPL_CHANNELLAYOUTTYPE_SPEAKERS and
    /// \c channelLayout is
    /// \c ::IPL_CHANNELLAYOUT_CUSTOM.
    pub numSpeakers: IPLint32,
    /// < An array of \c IPLVector3 objects indicating the
    /// direction of each speaker relative to the user.
    /// Can be \c NULL. Only used if \c channelLayoutType
    /// is \c ::IPL_CHANNELLAYOUTTYPE_SPEAKERS and
    /// \c channelLayout is
    /// \c ::IPL_CHANNELLAYOUT_CUSTOM.
    pub speakerDirections: *mut IPLVector3,
    /// < The order of Ambisonics to use. Must be between 0
    /// and 3. Ignored if \c channelLayoutType is
    /// \c ::IPL_CHANNELLAYOUTTYPE_SPEAKERS.
    pub ambisonicsOrder: IPLint32,
    /// < The ordering of Ambisonics channels within the
    /// data. Ignored if \c channelLayoutType is
    /// \c ::IPL_CHANNELLAYOUTTYPE_SPEAKERS.
    pub ambisonicsOrdering: IPLAmbisonicsOrdering,
    /// < The normalization scheme used for Ambisonics
    /// data. Ignored if \c channelLayoutType is
    /// \c ::IPL_CHANNELLAYOUTTYPE_SPEAKERS.
    pub ambisonicsNormalization: IPLAmbisonicsNormalization,
    /// < Whether the audio data is interleaved or
    /// deinterleaved.
    pub channelOrder: IPLChannelOrder,
}
#[test]
fn bindgen_test_layout_IPLAudioFormat() {
    assert_eq!(
        ::std::mem::size_of::<IPLAudioFormat>(),
        40usize,
        concat!("Size of: ", stringify!(IPLAudioFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLAudioFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(IPLAudioFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).channelLayoutType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(channelLayoutType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).channelLayout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(channelLayout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).numSpeakers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(numSpeakers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).speakerDirections as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(speakerDirections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).ambisonicsOrder as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(ambisonicsOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).ambisonicsOrdering as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(ambisonicsOrdering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLAudioFormat>())).ambisonicsNormalization as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(ambisonicsNormalization)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioFormat>())).channelOrder as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioFormat),
            "::",
            stringify!(channelOrder)
        )
    );
}
/// A buffer containing audio data. All audio data passed to or from Phonon must be packaged in \c IPLAudioBuffer
/// objects, which describe the format and size of the audio data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAudioBuffer {
    /// < The format of the audio data.
    pub format: IPLAudioFormat,
    /// < The number of samples in the audio buffer. The total number of
    /// elements in the audio buffer is equal to \c numSamples *
    /// \c format.numSpeakers.
    pub numSamples: IPLint32,
    /// < A pointer to a contiguous block of memory containing interleaved
    /// audio data in the format described by \c format. Can be \c NULL
    /// if \c format.channelOrder is \c ::IPL_CHANNELORDER_DEINTERLEAVED.
    pub interleavedBuffer: *mut IPLfloat32,
    /// < A pointer to an array of pointers, each of which points to a block
    /// of memory containing audio data for a single channel of audio data
    /// in the format described by \c format. In other words,
    /// deinterleaved audio data doesn't have to be stored contiguously
    /// in memory. Can be \c NULL if \c format.channelOrder is
    /// \c ::IPL_CHANNELORDER_INTERLEAVED.
    pub deinterleavedBuffer: *mut *mut IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLAudioBuffer() {
    assert_eq!(
        ::std::mem::size_of::<IPLAudioBuffer>(),
        64usize,
        concat!("Size of: ", stringify!(IPLAudioBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLAudioBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(IPLAudioBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioBuffer>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioBuffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioBuffer>())).numSamples as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioBuffer),
            "::",
            stringify!(numSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioBuffer>())).interleavedBuffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioBuffer),
            "::",
            stringify!(interleavedBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLAudioBuffer>())).deinterleavedBuffer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLAudioBuffer),
            "::",
            stringify!(deinterleavedBuffer)
        )
    );
}
extern "C" {
    /// Mixes a set of audio buffers.  This is primarily useful for mixing the output of multiple Panning Effect
    /// objects, before passing them to a single Virtual Surround Effect or a single Ambisonics Binaural Effect. This
    /// way, applications can significantly accelerate 3D audio rendering for large numbers of sources.
    ///
    /// \param  numBuffers          The number of input buffers to mix. Must be greater than 0.
    /// \param  inputAudio          Array of audio buffers to mix. All of these audio buffers must have identical
    /// formats.
    /// \param  outputAudio         Audio buffer that will contain the mixed audio data. The format of this buffer
    /// must be identical to all buffers contained in \c inputAudio.
    pub fn iplMixAudioBuffers(
        numBuffers: IPLint32,
        inputAudio: *mut IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Interleaves a deinterleaved audio buffer. The formats of \c inputAudio and \c outputAudio must be identical
    /// except for the \c channelOrder field.
    ///
    /// \param  inputAudio          The input audio buffer. This audio buffer must be deinterleaved.
    /// \param  outputAudio         The output audio buffer. This audio buffer must be interleaved.
    pub fn iplInterleaveAudioBuffer(
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Deinterleaves an interleaved audio buffer. The formats of \c inputAudio and \c outputAudio must be identical
    /// except for the \c channelOrder field.
    ///
    /// \param  inputAudio          The input audio buffer. This audio buffer must be interleaved.
    /// \param  outputAudio         The output audio buffer. This audio buffer must be deinterleaved.
    pub fn iplDeinterleaveAudioBuffer(
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Converts the format of an audio buffer into the format of the output audio buffer. This is primarily useful
    /// for 360 video and audio authoring workflows. The following format conversions are supported:
    ///
    /// - mono to multi-channel speaker-based formats (stereo, quadraphonic, 5.1, 7.1)
    /// - multi-channel speaker-based (stereo, quadraphonic, 5.1, 7.1) to mono
    /// - stereo to 5.1 or 7.1
    /// - Ambisonics to multi-channel speaker-based (mono, stereo, quadraphonic, 5.1, 7.1)
    ///
    /// \param  inputAudio          The input audio buffer.
    /// \param  outputAudio         The output audio buffer.
    pub fn iplConvertAudioBufferFormat(
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Creates an Ambisonics Rotator object. An Ambisonics Rotator object is used to apply an arbitrary rotation to
    /// audio data encoded in Ambisonics. This is primarily useful in the following situations:
    ///
    /// - If you have an Ambisonics audio buffer whose coefficients are defined relative to world space coordinates,
    /// you can convert them to listener space using an Ambisonics Rotator object. This is necessary when using a
    /// Convolution Effect object, since its output is defined in world space, and will not change if the listener
    /// looks around.
    ///
    /// - If your final mix is encoded in Ambisonics, and the user is using headphones with head tracking, you can use
    /// the Ambisonics Rotator object to make the sound field stay "in place" as the user looks around in the real
    /// world. This is achieved by using the Ambisonics Rotator object to apply the inverse of the user's rotation
    /// to the final mix.
    ///
    /// \param  context             The Context object used by the audio engine.
    /// \param  order               The order of the Ambisonics data to rotate.
    /// \param  rotator             [out] Handle to the created Ambisonics Rotator object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateAmbisonicsRotator(
        context: IPLhandle,
        order: IPLint32,
        rotator: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Ambisonics Rotator object.
    ///
    /// \param  rotator             [in, out] Address of a handle to the Ambisonics Rotator object to destroy.
    pub fn iplDestroyAmbisonicsRotator(rotator: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Specifies a rotation value. This function must be called before using \c ::iplRotateAmbisonicsAudioBuffer to
    /// rotate an Ambisonics-encoded audio buffer, or the resulting audio will be incorrect.
    ///
    /// \param  rotator             Handle to an Ambisonics Rotator object.
    /// \param  quaternion          A unit quaternion describing the 3D transformation from world space to listener
    /// space coordinates.
    pub fn iplSetAmbisonicsRotation(rotator: IPLhandle, quaternion: IPLQuaternion) -> IPLvoid;
}
extern "C" {
    /// Rotates an Ambisonics-encoded audio buffer. The \c ::iplSetAmbisonicsRotation function must have been called
    /// prior to calling this function, or the resulting audio will be incorrect. It is possible to pass the same
    /// value for \c inputAudio and \c outputAudio. This results in in-place rotation of the Ambisonics data.
    ///
    /// \param  rotator             Handle to an Ambisonics Rotator object.
    /// \param  inputAudio          Audio buffer containing the Ambisonics-encoded data that is to be rotated. The
    /// format of this buffer must be Ambisonics.
    /// \param  outputAudio         Audio buffer containing the rotated Ambisonics-encoded data. The format of this
    /// buffer must be Ambisonics.
    pub fn iplRotateAmbisonicsAudioBuffer(
        rotator: IPLhandle,
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
pub const IPLHrtfDatabaseType_IPL_HRTFDATABASETYPE_DEFAULT: IPLHrtfDatabaseType = 0;
pub const IPLHrtfDatabaseType_IPL_HRTFDATABASETYPE_CUSTOM: IPLHrtfDatabaseType = 1;
pub type IPLHrtfDatabaseType = u32;
/// A single-precision complex number.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLComplex {
    /// < The real part.
    pub real: IPLfloat32,
    /// < The imaginary part.
    pub imag: IPLfloat32,
}
#[test]
fn bindgen_test_layout_IPLComplex() {
    assert_eq!(
        ::std::mem::size_of::<IPLComplex>(),
        8usize,
        concat!("Size of: ", stringify!(IPLComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLComplex>())).real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComplex),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLComplex>())).imag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLComplex),
            "::",
            stringify!(imag)
        )
    );
}
/// A function that you can call to calculate the Fast Fourier Transform (FFT) of a real-valued time-domain
/// signal. You will typically call this from within your implementation of IPLHrtfLoadCallback, to transform your
/// time-domain Head-Related Impulse Responses (HRIRs) into Head-Related Transfer Functions (HRTFs).
///
/// \param  data                Pointer to internal data required for calculating Fourier transforms. This will be
/// passed in to your implementation of IPLHrtfLoadCallback.
/// \param  signal              Array containing the time-domain signal. The number of elements in this array must
/// match the signalSize parameter received by IPLHrtfLoadCallback.
/// \param  spectrum            Array containing the frequency-domain spectrum. The number of elements in this
/// array must match the spectrumSize parameter received by IPLHrtfLoadCallback.
pub type IPLFftHelper = ::std::option::Option<
    unsafe extern "C" fn(data: *mut IPLvoid,
                         signal: *mut IPLfloat32,
                         spectrum: *mut IPLComplex),
>;
/// Pointer to a function that will be called during the execution of iplCreateBinauralRenderer, to allow your
/// application to pre-transform all HRTF data into frequency domain.
///
/// \param  signalSize          Number of elements in the time-domain (HRIR) data arrays that must be transformed.
/// This will be greater than the actual size of the HRIRs passed to
/// iplCreateBinauralRenderer. Any array passed to fftHelper must contain the HRIR
/// data at the start, and the rest of the elements must be initialized to zero. For
/// example, if signalSize is 1024, and the HRIRs are 200 samples long, the arrays
/// passed to the signal parameter of fftHelper must be 1024 samples long, with the
/// first 200 samples containing the HRIR data, and the remaining 824 samples containing
/// zeroes.
/// \param  spectrumSize        Number of elements in the frequency-domain (HRTF) data arrays that will contain the
/// results of the transformation. You will typically allocate arrays of this size for
/// each HRIR; they must not be freed until IPLHrtfUnloadCallback is called.
/// \param  fftHelper           Pointer to a function that you can call to calculate the Fourier transforms of the
/// HRIRs.
/// \param  fftHelperData       Internal data required for calculating Fourier transforms. Pass this to fftHelper.
pub type IPLHrtfLoadCallback =
    ::std::option::Option<
        unsafe extern "C" fn(signalSize: IPLint32,
                             spectrumSize: IPLint32,
                             fftHelper: IPLFftHelper,
                             fftHelperData: *mut IPLvoid),
    >;
/// Pointer to a function that will be called during the execution of iplDestroyBinauralRenderer, to allow your
/// application to free memory allocated during IPLHrtfLoadCallback.
pub type IPLHrtfUnloadCallback = ::std::option::Option<unsafe extern "C" fn()>;
/// Pointer to a function that will be called during the execution of iplApplyBinauralEffect, to left your
/// application copy HRTF data for a given direction into arrays managed by Phonon.
///
/// \param  direction           Array containing the coordinates of the unit vector from the listener to the
/// source, in Cartesian coordinates.
/// \param  leftHrtf            Array into which you should copy the frequency-domain left-ear HRTF for the given
/// direction.
/// \param  rightHrtf           Array into which you should copy the frequency-domain right-ear HRTF for the given
/// direction.
pub type IPLHrtfLookupCallback =
    ::std::option::Option<
        unsafe extern "C" fn(direction: *mut IPLfloat32,
                             leftHrtf: *mut IPLComplex,
                             rightHrtf: *mut IPLComplex),
    >;
/// Parameters used to describe the HRTF database you want to use when creating a Binaural Renderer object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLHrtfParams {
    /// < Type of HRTF database to use.
    pub type_: IPLHrtfDatabaseType,
    /// < Reserved. Must be NULL.
    pub hrtfData: *mut IPLbyte,
    /// < If using custom HRTF data, the size of each
    /// time-domain HRIR.
    pub numHrirSamples: IPLint32,
    /// < Callback that will be called when creating
    /// a Binaural Renderer object.
    pub loadCallback: IPLHrtfLoadCallback,
    /// < Callback that will be called when destroying a
    /// Binaural Renderer object.
    pub unloadCallback: IPLHrtfUnloadCallback,
    /// < Callback that may be called to look up an HRTF
    /// and return a copy of the data.
    pub lookupCallback: IPLHrtfLookupCallback,
}
#[test]
fn bindgen_test_layout_IPLHrtfParams() {
    assert_eq!(
        ::std::mem::size_of::<IPLHrtfParams>(),
        48usize,
        concat!("Size of: ", stringify!(IPLHrtfParams))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLHrtfParams>(),
        8usize,
        concat!("Alignment of ", stringify!(IPLHrtfParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).hrtfData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(hrtfData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).numHrirSamples as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(numHrirSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).loadCallback as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(loadCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).unloadCallback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(unloadCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLHrtfParams>())).lookupCallback as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLHrtfParams),
            "::",
            stringify!(lookupCallback)
        )
    );
}
extern "C" {
    /// Creates a Binaural Renderer object. This function must be called before creating any Panning Effect objects,
    /// Object-Based Binaural Effect objects, Virtual Surround Effect objects, or Ambisonics Binaural Effect objects.
    /// Calling this function for the first time is somewhat expensive; avoid creating Binaural Renderer objects in
    /// your audio thread if at all possible. **This function is not thread-safe. It cannot be simultaneously called
    /// from multiple threads.**
    ///
    /// \param  context             The Context object used by the audio engine.
    /// \param  renderingSettings   An \c IPLRenderingSettings object describing the audio pipeline's DSP processing
    /// parameters. These properties must remain constant throughout the lifetime of your
    /// application.
    /// \param  params              Parameters describing the type of HRTF data you wish to use (built-in HRTF data or
    /// your own custom HRTF data).
    /// \param  renderer            [out] Handle to the created Binaural Renderer object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateBinauralRenderer(
        context: IPLhandle,
        renderingSettings: IPLRenderingSettings,
        params: IPLHrtfParams,
        renderer: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Binaural Renderer object. If any other API objects are still referencing the Binaural Renderer
    /// object, it will not be destroyed; destruction occurs when the object's reference count reaches zero.
    ///
    /// \param  renderer            [in, out] Address of a handle to the Binaural Renderer object to destroy.
    pub fn iplDestroyBinauralRenderer(renderer: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Creates a Panning Effect object. This can be used to render a point source on surround speakers, or using
    /// Ambisonics.
    ///
    /// \param  renderer            Handle to a Binaural Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyPanningEffect for this effect object must use
    /// \c IPLAudioBuffer objects with the same format as specified here. The input format
    /// must not be Ambisonics.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from
    /// this effect. All subsequent calls to \c ::iplApplyPanningEffect for this effect
    /// object must use \c IPLAudioBuffer objects with the same format as specified here.
    /// Any valid audio format may be specified as the output format.
    /// \param  effect              [out] Handle to the created Panning Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreatePanningEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Panning Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Panning Effect object to destroy.
    pub fn iplDestroyPanningEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies 3D panning to a buffer of audio data, using the configuration of a Panning Effect object. The input
    /// audio is treated as emanating from a single point. If the input audio buffer contains more than one channel,
    /// it will automatically be downmixed to mono.
    ///
    /// \param  effect              Handle to a Panning Effect object.
    /// \param  inputAudio          Audio buffer containing the data to render using 3D panning. The format of this
    /// buffer must match the \c inputFormat parameter passed to \c ::iplCreatePanningEffect.
    /// \param  direction           Unit vector from the listener to the point source, relative to the listener's
    /// coordinate system.
    /// \param  outputAudio         Audio buffer that should contain the rendered audio data. The format of this buffer
    /// must match the \c outputFormat parameter passed to \c ::iplCreatePanningEffect.
    pub fn iplApplyPanningEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        direction: IPLVector3,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by a Panning Effect object. This is useful if the Panning Effect object
    /// is going to be disabled/unused for a few frames; resetting the internal state will prevent an audible glitch
    /// when the Panning Effect object is re-enabled at a later time.
    ///
    /// \param  effect              Handle to a Panning Effect object.
    pub fn iplFlushPanningEffect(effect: IPLhandle) -> IPLvoid;
}
pub const IPLHrtfInterpolation_IPL_HRTFINTERPOLATION_NEAREST: IPLHrtfInterpolation = 0;
pub const IPLHrtfInterpolation_IPL_HRTFINTERPOLATION_BILINEAR: IPLHrtfInterpolation = 1;
pub type IPLHrtfInterpolation = u32;
extern "C" {
    /// Creates an Object-Based Binaural Effect object. This can be used to render a point source using HRTF-based
    /// binaural rendering.
    ///
    /// \param  renderer            Handle to a Binaural Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyBinauralEffect for this effect object must use
    /// \c IPLAudioBuffer objects with the same format as specified here. The input format
    /// must not be Ambisonics.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from this
    /// effect. All subsequent calls to \c ::iplApplyBinauralEffect for this effect object
    /// must use \c IPLAudioBuffer objects with the same format as specified here. The
    /// output format must be stereo (2 channels).
    /// \param  effect              [out] Handle to the created Object-Based Binaural Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateBinauralEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Object-Based Binaural Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Object-Based Binaural Effect object to
    /// destroy.
    pub fn iplDestroyBinauralEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies HRTF-based binaural rendering to a buffer of audio data. The input audio is treated as emanating from
    /// a single point. If the input audio buffer contains more than one channel, it will automatically be downmixed to
    /// mono. Using bilinear interpolation (by setting \c interpolation to \c ::IPL_HRTFINTERPOLATION_BILINEAR) can
    /// incur a relatively high CPU cost. Use it only on sources where nearest-neighbor filtering
    /// (\c ::IPL_HRTFINTERPOLATION_NEAREST) produces suboptimal results. Typically, bilinear filtering is most useful
    /// for wide-band noise-like sounds, such as radio static, mechanical noise, fire, etc.
    ///
    /// \param  effect              Handle to an Object-Based Binaural Effect object.
    /// \param  inputAudio          Audio buffer containing the data to render using binaural rendering. The format of
    /// this buffer must match the \c inputFormat parameter passed to
    /// \c ::iplCreateBinauralEffect.
    /// \param  direction           Unit vector from the listener to the point source, relative to the listener's
    /// coordinate system.
    /// \param  interpolation       The interpolation technique to use when rendering a point source at a location
    /// that is not contained in the measured HRTF data used by Phonon. **If using a custom
    /// HRTF database, this value must be set to IPL_HRTFINTERPOLATION_BILINEAR.**
    /// \param  outputAudio         Audio buffer that should contain the rendered audio data. The format of this
    /// buffer must match the \c outputFormat parameter passed to
    /// \c ::iplCreateBinauralEffect.
    pub fn iplApplyBinauralEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        direction: IPLVector3,
        interpolation: IPLHrtfInterpolation,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    pub fn iplApplyBinauralEffectWithParameters(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        direction: IPLVector3,
        interpolation: IPLHrtfInterpolation,
        outputAudio: IPLAudioBuffer,
        leftDelay: *mut IPLfloat32,
        rightDelay: *mut IPLfloat32,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by an Object-Based Binaural Effect object. This is useful if the
    /// Object-Based Binaural Effect object is going to be disabled/unused for a few frames; resetting the internal
    /// state will prevent an audible glitch when the Object-Based Binaural Effect object is re-enabled at a later
    /// time.
    ///
    /// \param  effect              Handle to an Object-Based Binaural Effect object.
    pub fn iplFlushBinauralEffect(effect: IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Creates a Virtual Surround Effect object. This can be used to render a multichannel surround sound data using
    /// HRTF-based binaural rendering.
    ///
    /// \param  renderer            Handle to a Binaural Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyVirtualSurroundEffect for this effect object must
    /// use \c IPLAudioBuffer objects with the same format as specified here. The input
    /// format must not be Ambisonics.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from this
    /// effect. All subsequent calls to \c ::iplApplyVirtualSurroundEffect for this effect
    /// object must use \c IPLAudioBuffer objects with the same format as specified here.
    /// The output format must be stereo (2 channels).
    /// \param  effect              [out] Handle to the created Virtual Surround Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateVirtualSurroundEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Virtual Surround Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Virtual Surround Effect object to destroy.
    pub fn iplDestroyVirtualSurroundEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies HRTF-based binaural rendering to a buffer of multichannel audio data.
    ///
    /// \param  effect              Handle to a Virtual Surround Effect.
    /// \param  inputAudio          Audio buffer containing the data to render using binaural rendering. The format of
    /// this buffer must match the \c inputFormat parameter passed to
    /// \c ::iplCreateVirtualSurroundEffect.
    /// \param  outputAudio         Audio buffer that should contain the rendered audio data. The format of this buffer
    /// must match the \c outputFormat parameter passed to
    /// \c ::iplCreateVirtualSurroundEffect.
    ///
    /// \remark When using a custom HRTF database, calling this function is not supported.
    pub fn iplApplyVirtualSurroundEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by a Virtual Surround Effect object. This is useful if the Virtual
    /// Surround Effect object is going to be disabled/unused for a few frames; resetting the internal state will
    /// prevent an audible glitch when the Virtual Surround Effect object is re-enabled at a later time.
    ///
    /// \param  effect              Handle to a Virtual Surround Effect object.
    pub fn iplFlushVirtualSurroundEffect(effect: IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Creates an Ambisonics Panning Effect object. This can be used to render higher-order Ambisonics data using
    /// standard panning algorithms.
    ///
    /// \param  renderer            Handle to a Binaural Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyAmbisonicsPanningEffect for this effect object must
    /// use \c IPLAudioBuffer objects with the same format as specified here. The input
    /// format must be Ambisonics.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from this
    /// effect. All subsequent calls to \c ::iplApplyAmbisonicsPanningEffect for this
    /// effect object must use \c IPLAudioBuffer objects with the same format as specified
    /// here.
    /// \param  effect              [out] Handle to the created Ambisonics Panning Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateAmbisonicsPanningEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Ambisonics Panning Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Ambisonics Panning Effect object to destroy.
    pub fn iplDestroyAmbisonicsPanningEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies a panning-based rendering algorithm to a buffer of Ambisonics audio data. Ambisonics encoders and decoders
    /// use many different conventions to store the multiple Ambisonics channels, as well as different normalization
    /// schemes. Make sure that you correctly specify these settings when creating the Ambisonics Panning Effect
    /// object, otherwise the rendered audio will be incorrect.
    ///
    /// \param  effect              Handle to an Ambisonics Panning Effect object.
    /// \param  inputAudio          Audio buffer containing the data to render. The format of
    /// this buffer must match the \c inputFormat parameter passed to
    /// \c ::iplCreateAmbisonicsPanningEffect.
    /// \param  outputAudio         Audio buffer that should contain the rendered audio data. The format of this buffer
    /// must match the \c outputFormat parameter passed to
    /// \c ::iplCreateAmbisonicsPanningEffect.
    pub fn iplApplyAmbisonicsPanningEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by an Ambisonics Panning Effect object. This is useful if the Ambisonics
    /// Panning Effect object is going to be disabled/unused for a few frames; resetting the internal state will
    /// prevent an audible glitch when the Ambisonics Panning Effect object is re-enabled at a later time.
    ///
    /// \param  effect              Handle to an Ambisonics Panning Effect object.
    pub fn iplFlushAmbisonicsPanningEffect(effect: IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Creates an Ambisonics Binaural Effect object. This can be used to render higher-order Ambisonics data using
    /// HRTF-based binaural rendering.
    ///
    /// \param  renderer            Handle to a Binaural Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyAmbisonicsBinauralEffect for this effect object must
    /// use \c IPLAudioBuffer objects with the same format as specified here. The input
    /// format must be Ambisonics.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from this
    /// effect. All subsequent calls to \c ::iplApplyAmbisonicsBinauralEffect for this
    /// effect object must use \c IPLAudioBuffer objects with the same format as specified
    /// here. The output format must be stereo (2 channels).
    /// \param  effect              [out] Handle to the created Ambisonics Binaural Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateAmbisonicsBinauralEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Ambisonics Binaural Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Ambisonics Binaural Effect object to destroy.
    pub fn iplDestroyAmbisonicsBinauralEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies HRTF-based binaural rendering to a buffer of Ambisonics audio data. Ambisonics encoders and decoders
    /// use many different conventions to store the multiple Ambisonics channels, as well as different normalization
    /// schemes. Make sure that you correctly specify these settings when creating the Ambisonics Binaural Effect
    /// object, otherwise the rendered audio will be incorrect.
    ///
    /// \param  effect              Handle to an Ambisonics Binaural Effect object.
    /// \param  inputAudio          Audio buffer containing the data to render using binaural rendering. The format of
    /// this buffer must match the \c inputFormat parameter passed to
    /// \c ::iplCreateAmbisonicsBinauralEffect.
    /// \param  outputAudio         Audio buffer that should contain the rendered audio data. The format of this buffer
    /// must match the \c outputFormat parameter passed to
    /// \c ::iplCreateAmbisonicsBinauralEffect.
    ///
    /// \remark When using a custom HRTF database, calling this function is not supported.
    pub fn iplApplyAmbisonicsBinauralEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by an Ambisonics Binaural Effect object. This is useful if the Ambisonics
    /// Binaural Effect object is going to be disabled/unused for a few frames; resetting the internal state will
    /// prevent an audible glitch when the Ambisonics Binaural Effect object is re-enabled at a later time.
    ///
    /// \param  effect              Handle to an Ambisonics Binaural Effect object.
    pub fn iplFlushAmbisonicsBinauralEffect(effect: IPLhandle) -> IPLvoid;
}
/// Callback function that is called when the simulation thread is created.
pub type IPLSimulationThreadCreateCallback = ::std::option::Option<unsafe extern "C" fn()>;
/// Callback function that is called when the simulation thread is destroyed.
pub type IPLSimulationThreadDestroyCallback = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    /// Creates an Environmental Renderer object.
    ///
    /// \param  context             The Context object used by the audio engine.
    /// \param  environment         Handle to an Environment object provided by the game engine. It is up to your
    /// application to pass this handle from the game engine to the audio engine.
    /// \param  renderingSettings   An \c IPLRenderingSettings object describing the audio pipeline's DSP processing
    /// parameters. These properties must remain constant throughout the lifetime of your
    /// application.
    /// \param  outputFormat        The audio format of the output buffers passed to any subsequent call to
    /// \c ::iplGetMixedEnvironmentalAudio. This format must not be changed once it is set
    /// during the call to this function.
    /// \param  threadCreateCallback    Pointer to a function that will be called when the internal simulation thread
    /// is created. May be NULL.
    /// \param  threadDestroyCallback   Pointer to a function that will be called when the internal simulation thread
    /// is destroyed. May be NULL.
    /// \param  renderer            [out] Handle to the created Environmental Renderer object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateEnvironmentalRenderer(
        context: IPLhandle,
        environment: IPLhandle,
        renderingSettings: IPLRenderingSettings,
        outputFormat: IPLAudioFormat,
        threadCreateCallback: IPLSimulationThreadCreateCallback,
        threadDestroyCallback: IPLSimulationThreadDestroyCallback,
        renderer: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys an Environmental Renderer object. If any other API objects are still referencing the Environmental
    /// Renderer object, the object will not be destroyed; it will only be destroyed once its reference count reaches
    /// zero.
    ///
    /// \param  renderer            [in, out] Address of a handle to the Environmental Renderer object to destroy.
    pub fn iplDestroyEnvironmentalRenderer(renderer: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// \}
    pub fn iplCreateSimulationData(
        simulationSettings: IPLSimulationSettings,
        renderingSettings: IPLRenderingSettings,
        simulationData: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    pub fn iplDestroySimulationData(simulationData: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    pub fn iplGetNumIrSamples(simulationData: IPLhandle) -> IPLint32;
}
extern "C" {
    pub fn iplGetNumIrChannels(simulationData: IPLhandle) -> IPLint32;
}
extern "C" {
    pub fn iplGenerateSimulationData(
        simulationData: IPLhandle,
        environment: IPLhandle,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
        sources: *mut IPLVector3,
    ) -> IPLvoid;
}
extern "C" {
    pub fn iplGetSimulationResult(
        simulationData: IPLhandle,
        sourceIndex: IPLint32,
        channel: IPLint32,
        buffer: *mut IPLfloat32,
    ) -> IPLvoid;
}
pub const IPLDirectOcclusionMethod_IPL_DIRECTOCCLUSION_RAYCAST: IPLDirectOcclusionMethod = 0;
pub const IPLDirectOcclusionMethod_IPL_DIRECTOCCLUSION_VOLUMETRIC: IPLDirectOcclusionMethod = 1;
pub type IPLDirectOcclusionMethod = u32;
pub const IPLDirectOcclusionMode_IPL_DIRECTOCCLUSION_NONE: IPLDirectOcclusionMode = 0;
pub const IPLDirectOcclusionMode_IPL_DIRECTOCCLUSION_NOTRANSMISSION: IPLDirectOcclusionMode = 1;
pub const IPLDirectOcclusionMode_IPL_DIRECTOCCLUSION_TRANSMISSIONBYVOLUME : IPLDirectOcclusionMode = 2 ;
pub const IPLDirectOcclusionMode_IPL_DIRECTOCCLUSION_TRANSMISSIONBYFREQUENCY : IPLDirectOcclusionMode = 3 ;
pub type IPLDirectOcclusionMode = u32;
/// Parameters describing a direct sound path. For each frequency band, the attenuation factor applied to the
/// direct sound path is:
///
/// distanceAttenuation * airAbsorption * (occlusionFactor + (1 - occlusionFactor) * transmissionFactor)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDirectSoundPath {
    /// < Unit vector from the listener to the source.
    pub direction: IPLVector3,
    /// < Scaling factor to apply to direct sound, that arises due to the
    /// spherical attenuation of sound with distance from the source.
    /// Linear scale from 0.0 to 1.0.
    pub distanceAttenuation: IPLfloat32,
    /// < Scaling factors to apply to direct sound, for low, middle, and high
    /// frequencies, that arise due to the scattering of sound waves as they
    /// travel through the air. Linear scale from 0.0 to 1.0.
    pub airAbsorption: [IPLfloat32; 3usize],
    /// < Time delay (in seconds) due to propagation from the source to the
    /// listener.
    pub propagationDelay: IPLfloat32,
    /// < Scaling factor to apply to direct sound, that arises due to occlusion
    /// by scene geometry. Linear scale from 0.0 to 1.0.
    pub occlusionFactor: IPLfloat32,
    /// < Scaling factors to apply to direct sound, for low, middle, and high
    /// frequencies, that arise due to the transmission of sound waves through
    /// scene geometry. Linear scale from 0.0 to 1.0.
    pub transmissionFactor: [IPLfloat32; 3usize],
}
#[test]
fn bindgen_test_layout_IPLDirectSoundPath() {
    assert_eq!(
        ::std::mem::size_of::<IPLDirectSoundPath>(),
        48usize,
        concat!("Size of: ", stringify!(IPLDirectSoundPath))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLDirectSoundPath>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLDirectSoundPath))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLDirectSoundPath>())).direction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLDirectSoundPath>())).distanceAttenuation as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(distanceAttenuation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLDirectSoundPath>())).airAbsorption as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(airAbsorption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLDirectSoundPath>())).propagationDelay as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(propagationDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLDirectSoundPath>())).occlusionFactor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(occlusionFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLDirectSoundPath>())).transmissionFactor as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundPath),
            "::",
            stringify!(transmissionFactor)
        )
    );
}
extern "C" {
    /// Calculates direct sound path parameters for a single source. It is up to the audio engine to perform audio
    /// processing that uses the information returned by this function.
    ///
    /// \param  environment         Handle to an Environment object.
    /// \param  listenerPosition    World-space position of the listener.
    /// \param  listenerAhead       Unit vector pointing in the direction in which the listener is looking.
    /// \param  listenerUp          Unit vector pointing upwards from the listener.
    /// \param  sourcePosition      World-space position of the source.
    /// \param  sourceRadius        Radius of the sphere defined around the source, for use with
    /// \c ::IPL_DIRECTOCCLUSION_VOLUMETRIC only.
    /// \param  occlusionMode       Confuguring the occlusion mode for direct path.
    /// \param  occlusionMethod     Algorithm to use for checking for direct path occlusion.
    ///
    /// \return Parameters of the direct path from the source to the listener.
    pub fn iplGetDirectSoundPath(
        environment: IPLhandle,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
        sourcePosition: IPLVector3,
        sourceRadius: IPLfloat32,
        occlusionMode: IPLDirectOcclusionMode,
        occlusionMethod: IPLDirectOcclusionMethod,
    ) -> IPLDirectSoundPath;
}
/// Flags that specify which parameters from \c IPLDirectSoundPath should be applied by the Direct Sound Effect.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDirectSoundEffectOptions {
    /// < Whether to apply distance attenuation.
    pub applyDistanceAttenuation: IPLbool,
    /// < Whether to apply frequency-dependent air absorption.
    pub applyAirAbsorption: IPLbool,
    /// < Whether to apply occlusion and transmission. Also
    /// lets you specify whether to apply frequency-dependent
    /// or frequency-independent transmission.
    pub directOcclusionMode: IPLDirectOcclusionMode,
}
#[test]
fn bindgen_test_layout_IPLDirectSoundEffectOptions() {
    assert_eq!(
        ::std::mem::size_of::<IPLDirectSoundEffectOptions>(),
        12usize,
        concat!("Size of: ", stringify!(IPLDirectSoundEffectOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLDirectSoundEffectOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLDirectSoundEffectOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLDirectSoundEffectOptions>())).applyDistanceAttenuation as
                *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundEffectOptions),
            "::",
            stringify!(applyDistanceAttenuation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLDirectSoundEffectOptions>())).applyAirAbsorption as
                *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundEffectOptions),
            "::",
            stringify!(applyAirAbsorption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLDirectSoundEffectOptions>())).directOcclusionMode as
                *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLDirectSoundEffectOptions),
            "::",
            stringify!(directOcclusionMode)
        )
    );
}
extern "C" {
    /// Creates a Direct Sound Effect object.
    ///
    /// \param  renderer            Handle to an Environmental Renderer object.
    /// \param  inputFormat         The format of the audio buffers that will be passed as input to this effect. All
    /// subsequent calls to \c ::iplApplyDirectSoundEffect for this effect object must use
    /// \c IPLAudioBuffer objects with the same format as specified here.
    /// \param  outputFormat        The format of the audio buffers which will be used to retrieve the output from this
    /// effect. All subsequent calls to \c ::iplApplyDirectSoundEffect for this effect
    /// object must use \c IPLAudioBuffer objects with the same format as specified here.
    /// \param  effect              [out] Handle to the created Direct Sound Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateDirectSoundEffect(
        renderer: IPLhandle,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Direct Sound Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Direct Sound Effect object to destroy.
    pub fn iplDestroyDirectSoundEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Applies various parameters in \c IPLDirectSoundPath to a buffer of audio data.
    ///
    /// \param  effect              Handle to a Direct Sound Effect object.
    /// \param  inputAudio          Audio buffer containing the dry audio data. The format of this buffer must match the
    /// \c inputFormat parameter passed to \c ::iplCreateDirectSoundEffect.
    /// \param  directSoundPath     Parameters of the direct path from the source to the listener.
    /// \param  options             Specifies which parameters from \c IPLDirectSoundPath should be processed by
    /// the Direct Sound Effect.
    /// \param  outputAudio         Audio buffer that should contain the wet audio data. The format of this buffer must
    /// match the \c outputFormat parameter passed to \c ::iplCreateDirectSoundEffect.
    pub fn iplApplyDirectSoundEffect(
        effect: IPLhandle,
        inputAudio: IPLAudioBuffer,
        directSoundPath: IPLDirectSoundPath,
        options: IPLDirectSoundEffectOptions,
        outputAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by a Direct Sound Effect object. This is useful if the
    /// Direct Sound Effect object is going to be disabled/unused for a few frames; resetting the internal
    /// state will prevent an audible glitch when the Direct Sound Effect object is re-enabled at a later
    /// time.
    ///
    /// \param  effect              Handle to a Direct Sound Effect object.
    pub fn iplFlushDirectSoundEffect(effect: IPLhandle) -> IPLvoid;
}
pub const IPLBakedDataType_IPL_BAKEDDATATYPE_STATICSOURCE: IPLBakedDataType = 0;
pub const IPLBakedDataType_IPL_BAKEDDATATYPE_STATICLISTENER: IPLBakedDataType = 1;
pub const IPLBakedDataType_IPL_BAKEDDATATYPE_REVERB: IPLBakedDataType = 2;
pub type IPLBakedDataType = u32;
/// Identifies a set of baked data. It is the application's responsibility to ensure that this data is unique
/// across the lifetime of an Environment object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBakedDataIdentifier {
    /// < 32-bit signed integer that uniquely identifies this set of baked data.
    pub identifier: IPLint32,
    /// < How this set of baked data should be interpreted.
    pub type_: IPLBakedDataType,
}
#[test]
fn bindgen_test_layout_IPLBakedDataIdentifier() {
    assert_eq!(
        ::std::mem::size_of::<IPLBakedDataIdentifier>(),
        8usize,
        concat!("Size of: ", stringify!(IPLBakedDataIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLBakedDataIdentifier>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLBakedDataIdentifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBakedDataIdentifier>())).identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBakedDataIdentifier),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBakedDataIdentifier>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBakedDataIdentifier),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// Creates a Convolution Effect object.
    ///
    /// \param  renderer            Handle to an Environmental Renderer object.
    /// \param  identifier          Unique identifier of the corresponding source, as defined in the baked data
    /// exported by the game engine. Each Convolution Effect object may have an identifier,
    /// which is used only if the Environment object provided by the game engine uses baked
    /// data for sound propagation. If so, the identifier of the Convolution Effect is used
    /// to look up the appropriate information from the baked data. Multiple Convolution
    /// Effect objects may be created with the same identifier; in that case they will use
    /// the same baked data.
    /// \param  simulationType      Whether this Convolution Effect object should use baked data or real-time simulation.
    /// \param  inputFormat         Format of all audio buffers passed as input to
    /// \c ::iplSetDryAudioForConvolutionEffect.
    /// \param  outputFormat        Format of all output audio buffers passed to \c ::iplGetWetAudioForConvolutionEffect.
    /// \param  effect              [out] Handle to the created Convolution Effect object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateConvolutionEffect(
        renderer: IPLhandle,
        identifier: IPLBakedDataIdentifier,
        simulationType: IPLSimulationType,
        inputFormat: IPLAudioFormat,
        outputFormat: IPLAudioFormat,
        effect: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Convolution Effect object.
    ///
    /// \param  effect              [in, out] Address of a handle to the Convolution Effect object to destroy.
    pub fn iplDestroyConvolutionEffect(effect: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Changes the identifier associated with a Convolution Effect object. This is useful when using a static listener
    /// bake, where you may want to teleport the listener between two or more locations for which baked data has
    /// been generated.
    ///
    /// \param  effect              Handle to a Convolution Effect object.
    /// \param  identifier          The new identifier of the Convolution Effect object.
    pub fn iplSetConvolutionEffectIdentifier(
        effect: IPLhandle,
        identifier: IPLBakedDataIdentifier,
    ) -> IPLvoid;
}
extern "C" {
    /// Specifies a frame of dry audio for a Convolution Effect object. This is the audio data to which sound
    /// propagation effects should be applied.
    ///
    /// \param  effect              Handle to a Convolution Effect object.
    /// \param  sourcePosition      World-space position of the sound source emitting the dry audio.
    /// \param  dryAudio            Audio buffer containing the dry audio data.
    pub fn iplSetDryAudioForConvolutionEffect(
        effect: IPLhandle,
        sourcePosition: IPLVector3,
        dryAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Retrieves a frame of wet audio from a Convolution Effect object. This is the result of applying sound
    /// propagation effects to the dry audio previously specified using \c ::iplSetDryAudioForConvolutionEffect.
    ///
    /// \param  effect              Handle to a Convolution Effect object.
    /// \param  listenerPosition    World-space position of the listener.
    /// \param  listenerAhead       Unit vector in the direction in which the listener is looking.
    /// \param  listenerUp          Unit vector pointing upwards from the listener.
    /// \param  wetAudio            Audio buffer which will be populated with the wet audio data.
    pub fn iplGetWetAudioForConvolutionEffect(
        effect: IPLhandle,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
        wetAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Retrieves a mixed frame of wet audio. This is the sum of all wet audio data from all Convolution Effect
    /// objects that were created using the given Environmental Renderer object. Unless using TrueAudio Next for
    /// convolution, this is likely to provide a significant performance boost to the audio thread as compared to
    /// calling \c ::iplGetWetAudioForConvolutionEffect for each Convolution Effect separately. On the other hand, doing
    /// so makes it impossible to apply additional DSP effects for specific sources before mixing.
    ///
    /// \param  renderer            Handle to an Environmental Renderer object.
    /// \param  listenerPosition    World-space position of the listener.
    /// \param  listenerAhead       Unit vector in the direction in which the listener is looking.
    /// \param  listenerUp          Unit vector pointing upwards from the listener.
    /// \param  mixedWetAudio       Audio buffer which will be populated with the wet audio data.
    pub fn iplGetMixedEnvironmentalAudio(
        renderer: IPLhandle,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
        mixedWetAudio: IPLAudioBuffer,
    ) -> IPLvoid;
}
extern "C" {
    /// Resets any internal state maintained by a Convolution Effect object. This is useful if the Convolution Effect
    /// object is going to be disabled/unused for a few frames; resetting the internal state will prevent an audible
    /// glitch when the Convolution Effect object is re-enabled at a later time.
    ///
    /// \param  effect              Handle to a Convolution Effect object.
    pub fn iplFlushConvolutionEffect(effect: IPLhandle) -> IPLvoid;
}
pub const IPLProbePlacement_IPL_PLACEMENT_CENTROID: IPLProbePlacement = 0;
pub const IPLProbePlacement_IPL_PLACEMENT_OCTREE: IPLProbePlacement = 1;
pub const IPLProbePlacement_IPL_PLACEMENT_UNIFORMFLOOR: IPLProbePlacement = 2;
pub type IPLProbePlacement = u32;
/// Parameters that specify how probes should be created by \c ::iplCreateProbeBox.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLProbePlacementParams {
    /// < The placement algorithm to use for creating probes.
    pub placement: IPLProbePlacement,
    /// < Spacing between probes along the horizontal plane. Only
    /// used if \c placement is \c ::IPL_PLACEMENT_UNIFORMFLOOR.
    pub spacing: IPLfloat32,
    /// < Height of the probes above the closest floor or terrain
    /// surfaces. Only used if \c placement is
    /// \c ::IPL_PLACEMENT_UNIFORMFLOOR.
    pub heightAboveFloor: IPLfloat32,
    /// < The maximum number of triangles to store in an octree leaf
    /// node. Only used if \c placement is \c ::IPL_PLACEMENT_OCTREE.
    pub maxOctreeTriangles: IPLint32,
    /// < The maximum depth of the octree. Increasing this value increases
    /// density of the generated probes. Only used if \c placement is
    /// \c ::IPL_PLACEMENT_OCTREE.
    pub maxOctreeDepth: IPLint32,
}
#[test]
fn bindgen_test_layout_IPLProbePlacementParams() {
    assert_eq!(
        ::std::mem::size_of::<IPLProbePlacementParams>(),
        20usize,
        concat!("Size of: ", stringify!(IPLProbePlacementParams))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLProbePlacementParams>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLProbePlacementParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLProbePlacementParams>())).placement as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLProbePlacementParams),
            "::",
            stringify!(placement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLProbePlacementParams>())).spacing as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLProbePlacementParams),
            "::",
            stringify!(spacing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLProbePlacementParams>())).heightAboveFloor as *const _ as
                usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLProbePlacementParams),
            "::",
            stringify!(heightAboveFloor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLProbePlacementParams>())).maxOctreeTriangles as *const _ as
                usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLProbePlacementParams),
            "::",
            stringify!(maxOctreeTriangles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IPLProbePlacementParams>())).maxOctreeDepth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLProbePlacementParams),
            "::",
            stringify!(maxOctreeDepth)
        )
    );
}
/// A callback that is called to update the application on the progress of the \c ::iplCreateProbeBox function.
/// You can use this to provide visual feedback to the user, like a progress bar.
///
/// \param  progress            Fraction of the probe generation process that has been completed, between
/// 0.0 and 1.0.
pub type IPLProbePlacementProgressCallback =
    ::std::option::Option<unsafe extern "C" fn(progress: IPLfloat32)>;
extern "C" {
    /// Generates probes within a box. This function should typically be called from the game engine's editor, in
    /// response to the user indicating that they want to generate probes in the scene.
    ///
    /// \param  context                     Handle to the Context object used by the game engine.
    /// \param  scene                       Handle to the Scene object.
    /// \param  boxLocalToWorldTransform    4x4 local to world transform matrix laid out in column-major format.
    /// \param  placementParams             Parameters specifying how probes should be generated.
    /// \param  progressCallback            Pointer to a function that reports the percentage of this function's
    /// work that has been completed. May be \c NULL.
    /// \param  probeBox                    [out] Handle to the created Probe Box object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateProbeBox(
        context: IPLhandle,
        scene: IPLhandle,
        boxLocalToWorldTransform: *mut IPLfloat32,
        placementParams: IPLProbePlacementParams,
        progressCallback: IPLProbePlacementProgressCallback,
        probeBox: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Destroys a Probe Box object.
    ///
    /// \param  probeBox            [in, out] Address of a handle to the Probe Box object to destroy.
    pub fn iplDestroyProbeBox(probeBox: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Retrieves spheres describing the positions and influence radii of all probes in the Probe Box object. This
    /// function should typically be called from the game engine's editor, and the retrieved spheres should be used
    /// for visualization.
    ///
    /// \param  probeBox            Handle to a Probe Box object.
    /// \param  probeSpheres        [out] Array into which information about the probe spheres is returned. It is the
    /// the caller's responsibility to manage memory for this array. The array must be
    /// large enough to hold all the spheres in the Probe Box object. May be \c NULL, in
    /// which case no spheres are returned; this is useful when finding out the number of
    /// probes in the Probe Box object.
    ///
    /// \return The number of probes in the Probe Box object.
    pub fn iplGetProbeSpheres(probeBox: IPLhandle, probeSpheres: *mut IPLSphere) -> IPLint32;
}
extern "C" {
    /// Serializes a Probe Box object to a byte array. This is typically called by the game engine's editor in order
    /// to save the Probe Box object's data to disk.
    ///
    /// \param  probeBox            Handle to a Probe Box object.
    /// \param  data                [out] Byte array into which the Probe Box object will be serialized. It is the
    /// caller's responsibility to manage memory for this array. The array must be large
    /// enough to hold all the data in the Probe Box object. May be \c NULL, in which case
    /// no data is returned; this is useful when finding out the size of the data stored
    /// in the Probe Box object.
    ///
    /// \return Size (in bytes) of the serialized data.
    pub fn iplSaveProbeBox(probeBox: IPLhandle, data: *mut IPLbyte) -> IPLint32;
}
extern "C" {
    /// Deserializes a Probe Box object from a byte array. This is typically called by the game engine's editor when
    /// loading a Probe Box object from disk.
    ///
    /// \param  context             Handle to the Context object used by the game engine.
    /// \param  data                Byte array containing the serialized representation of the Probe Box object. Must
    /// not be \c NULL.
    /// \param  size                Size (in bytes) of the serialized data.
    /// \param  probeBox            [out] Handle to the created Probe Box object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplLoadProbeBox(
        context: IPLhandle,
        data: *mut IPLbyte,
        size: IPLint32,
        probeBox: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Creates a Probe Batch object. A Probe Batch object represents a set of probes that are loaded and unloaded
    /// from memory as a unit when the game is played. A Probe Batch may contain probes from multiple Probe Boxes;
    /// multiple Probe Batches may contain probes from the same Probe Box. At run-time, Phonon does not use Probe
    /// Boxes, it only needs Probe Batches. The typical workflow is as follows:
    ///
    /// 1.  Using the editor, the designer creates Probe Boxes to sample the scene.
    /// 2.  Using the editor, the designer specifies Probe Batches, and decides which probes are part of each Probe
    /// Batch.
    /// 3.  The editor saves the Probe Batches along with the rest of the scene data for use at run-time.
    /// 4.  At run-time, Phonon uses the Probe Batches to retrieve baked data.
    ///
    /// \param  context             Handle to the Context object used by the game engine.
    /// \param  probeBatch          [out] Handle to the created Probe Batch object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateProbeBatch(context: IPLhandle, probeBatch: *mut IPLhandle) -> IPLerror;
}
extern "C" {
    /// Destroys a Probe Batch object.
    ///
    /// \param  probeBatch          [in, out] Address of a handle to the Probe Batch object to destroy.
    pub fn iplDestroyProbeBatch(probeBatch: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Adds a specific probe from a Probe Box to a Probe Batch. Once all probes in a Probe Box have been assigned to
    /// their respective Probe Batches, you can destroy the Probe Box object; the baked data for the probes will
    /// be retained by the Probe Batch.
    ///
    /// \param  probeBatch          Handle to a Probe Batch object into which the probe should be added.
    /// \param  probeBox            Handle to a Probe Box object from which the probe should be added.
    /// \param  probeIndex          Index of the probe to add. The index is defined relative to the array of probes
    /// returned by \c ::iplGetProbeSpheres.
    pub fn iplAddProbeToBatch(
        probeBatch: IPLhandle,
        probeBox: IPLhandle,
        probeIndex: IPLint32,
    ) -> IPLvoid;
}
extern "C" {
    /// Finalizes the set of probes that comprise a Probe Batch. Calling this function builds internal data
    /// structures that are used to rapidly determine which probes influence any given point in 3D space. You may
    /// not call \c ::iplAddProbeToBatch after calling this function. You must call this function before calling
    /// \c ::iplAddProbeBatch to add this Probe Batch object to a Probe Manager object.
    ///
    /// \param  probeBatch          Handle to a ProbeBatch object.
    pub fn iplFinalizeProbeBatch(probeBatch: IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Serializes a Probe Batch object to a byte array. This is typically called by the game engine's editor in order
    /// to save the Probe Batch object's data to disk.
    ///
    /// \param  probeBatch          Handle to a Probe Batch object.
    /// \param  data                [out] Byte array into which the Probe Batch object will be serialized. It is the
    /// caller's responsibility to manage memory for this array. The array must be large
    /// enough to hold all the data in the Probe Batch object. May be \c NULL, in which
    /// case no data is returned; this is useful when finding out the size of the data
    /// stored in the Probe Batch object.
    ///
    /// \return Size (in bytes) of the serialized data.
    pub fn iplSaveProbeBatch(probeBatch: IPLhandle, data: *mut IPLbyte) -> IPLint32;
}
extern "C" {
    /// Deserializes a Probe Batch object from a byte array. This is typically called by the game engine's editor when
    /// loading a Probe Batch object from disk. Calling this function implicitly calls \c ::iplFinalizeProbeBatch, so
    /// you do not need to call it explicitly.
    ///
    /// \param  context             Handle to the Context object used by the game engine.
    /// \param  data                Byte array containing the serialized representation of the Probe Batch object. Must
    /// not be \c NULL.
    /// \param  size                Size (in bytes) of the serialized data.
    /// \param  probeBatch          [out] Handle to the created Probe Batch object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplLoadProbeBatch(
        context: IPLhandle,
        data: *mut IPLbyte,
        size: IPLint32,
        probeBatch: *mut IPLhandle,
    ) -> IPLerror;
}
extern "C" {
    /// Creates a Probe Manager object. A Probe Manager object manages a set of Probe Batch objects are runtime.
    /// It is typically exported from the game engine to the audio engine via an Environment object. Probe Batch
    /// objects can be dynamically added to or removed from a Probe Manager object.
    ///
    /// \param  context             Handle to the Context object used by the game engine.
    /// \param  probeManager        [out] Handle to the created Probe Manager object.
    ///
    /// \return Status code indicating whether or not the operation succeeded.
    pub fn iplCreateProbeManager(context: IPLhandle, probeManager: *mut IPLhandle) -> IPLerror;
}
extern "C" {
    /// Destroys a Probe Manager object.
    ///
    /// \param  probeManager        [in, out] Address of a handle to the Probe Manager object to destroy.
    pub fn iplDestroyProbeManager(probeManager: *mut IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Adds a Probe Batch to a Probe Manager object. Once this function returns, probes in the Probe Batch will be
    /// used to calculate sound propagation effects.
    ///
    /// \param  probeManager        Handle to a Probe Manager object.
    /// \param  probeBatch          Handle to the Probe Batch object to add.
    pub fn iplAddProbeBatch(probeManager: IPLhandle, probeBatch: IPLhandle) -> IPLvoid;
}
extern "C" {
    /// Removes a Probe Batch from a Probe Manager object. Once this function returns, probes in the Probe Batch will
    /// no longer be used to calculate sound propagation effects.
    ///
    /// \param  probeManager        Handle to a Probe Manager object.
    /// \param  probeBatch          Handle to the Probe Batch object to remove.
    pub fn iplRemoveProbeBatch(probeManager: IPLhandle, probeBatch: IPLhandle) -> IPLvoid;
}
/// Specifies the kind of acoustic responses to save in the baked data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBakingSettings {
    /// < Enables the generation of I3DL2-compliant parametric reverb. This is most
    /// suited for calculating reverb in relatively enclosed spaces. It is less
    /// suitable for open spaces, or source-to-listener propagation. It consumes
    /// very little memory per probe.
    pub bakeParametric: IPLbool,
    /// < Enables the generation of detailed impulse responses for convolution reverb.
    /// This is suited for all kinds of spaces, and for reverb as well as
    /// source-to-listener propagation. However, it consumes significantly more
    /// memory per probe.
    pub bakeConvolution: IPLbool,
}
#[test]
fn bindgen_test_layout_IPLBakingSettings() {
    assert_eq!(
        ::std::mem::size_of::<IPLBakingSettings>(),
        8usize,
        concat!("Size of: ", stringify!(IPLBakingSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<IPLBakingSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(IPLBakingSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBakingSettings>())).bakeParametric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBakingSettings),
            "::",
            stringify!(bakeParametric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IPLBakingSettings>())).bakeConvolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IPLBakingSettings),
            "::",
            stringify!(bakeConvolution)
        )
    );
}
/// A callback that is called to update the application on the progress of the \c ::iplBakeReverb or
/// \c ::iplBakePropagation functions. You can use this to provide visual feedback to the user, like a progress
/// bar.
///
/// \param  progress            Fraction of the baking process that has been completed, between 0.0 and 1.0.
pub type IPLBakeProgressCallback =
    ::std::option::Option<unsafe extern "C" fn(progress: IPLfloat32)>;
extern "C" {
    /// Bakes reverb at all probes in a Probe Box. Phonon defines reverb as the indirect sound received at a probe
    /// when a source is placed at the probe's location. This is a time-consuming operation, and should typically be
    /// called from the game engine's editor.
    ///
    /// \param  environment         Handle to an Environment object.
    /// \param  probeBox            Handle to the Probe Box containing the probes for which to bake reverb.
    /// \param  bakingSettings      The kind of acoustic responses to bake.
    /// \param  progressCallback    Pointer to a function that reports the percentage of this function's work that
    /// has been completed. May be \c NULL.
    pub fn iplBakeReverb(
        environment: IPLhandle,
        probeBox: IPLhandle,
        bakingSettings: IPLBakingSettings,
        progressCallback: IPLBakeProgressCallback,
    ) -> IPLvoid;
}
extern "C" {
    /// Bakes propagation effects from a specified source to all probes in a Probe Box. Sources are defined in terms
    /// of a position and a sphere of influence; all probes in the Probe Box that lie within the sphere of influence
    /// are processed by this function. This is a time-consuming operation, and should typically be called from the
    /// game engine's editor.
    ///
    /// \param  environment         Handle to an Environment object.
    /// \param  probeBox            Handle to the Probe Box containing the probes for which to bake reverb.
    /// \param  sourceInfluence     Sphere defined by the source position (at its center) and its radius of
    /// influence.
    /// \param  sourceIdentifier    Identifier of the source. At run-time, a Convolution Effect object can use this
    /// identifier to look up the correct impulse response information.
    /// \param  bakingSettings      The kind of acoustic responses to bake.
    /// \param  progressCallback    Pointer to a function that reports the percentage of this function's work that
    /// has been completed. May be \c NULL.
    pub fn iplBakePropagation(
        environment: IPLhandle,
        probeBox: IPLhandle,
        sourceInfluence: IPLSphere,
        sourceIdentifier: IPLBakedDataIdentifier,
        bakingSettings: IPLBakingSettings,
        progressCallback: IPLBakeProgressCallback,
    ) -> IPLvoid;
}
extern "C" {
    /// Bakes propagation effects from all probes in a Probe Box to a specified listener. Listeners are defined
    /// solely by their position; their orientation may freely change at run-time. This is a time-consuming
    /// operation, and should typically be called from the game engine's editor.
    ///
    /// \param  environment         Handle to an Environment object.
    /// \param  probeBox            Handle to the Probe Box containing the probes for which to bake reverb.
    /// \param  listenerInfluence   Position and influence radius of the listener.
    /// \param  listenerIdentifier  Identifier of the listener. At run-time, a Convolution Effect object can use this
    /// identifier to look up the correct impulse response information.
    /// \param  bakingSettings      The kind of acoustic responses to bake.
    /// \param  progressCallback    Pointer to a function that reports the percentage of this function's work that
    /// has been completed. May be \c NULL.
    pub fn iplBakeStaticListener(
        environment: IPLhandle,
        probeBox: IPLhandle,
        listenerInfluence: IPLSphere,
        listenerIdentifier: IPLBakedDataIdentifier,
        bakingSettings: IPLBakingSettings,
        progressCallback: IPLBakeProgressCallback,
    ) -> IPLvoid;
}
extern "C" {
    /// Cancels any bake operations that may be in progress. Typically, an application will call \c ::iplBakeReverb
    /// or \c ::iplBakePropagation in a separate thread from the editor's GUI thread, to keep the GUI responsive.
    /// This function can be called from the GUI thread to safely and prematurely terminate execution of any
    /// of these functions.
    pub fn iplCancelBake() -> IPLvoid;
}
extern "C" {
    /// Deletes all baked data in a Probe Box that is associated with a given source. If no such baked data
    /// exists, this function does nothing.
    ///
    /// \param  probeBox            Handle to a Probe Box object.
    /// \param  identifier          Identifier of the source whose baked data is to be deleted.
    pub fn iplDeleteBakedDataByIdentifier(
        probeBox: IPLhandle,
        identifier: IPLBakedDataIdentifier,
    ) -> IPLvoid;
}
extern "C" {
    /// Returns the size (in bytes) of the baked data stored in a Probe Box corresponding to a given source.
    /// This is useful for displaying statistics in the editor's GUI.
    ///
    /// \param  probeBox            Handle to a Probe Box object.
    /// \param  identifier          Identifier of the source whose baked data size is to be returned.
    ///
    /// \return Size (in bytes) of the baked data stored in the Probe Box corresponding to the source.
    pub fn iplGetBakedDataSizeByIdentifier(
        probeBox: IPLhandle,
        identifier: IPLBakedDataIdentifier,
    ) -> IPLint32;
}
