#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
extern crate gl;
extern crate glfw;
extern crate lewton;
extern crate steam_audio;

use lewton::inside_ogg::{OggStreamReader, read_headers};
use steam_audio::ffi::*;

use std::error::Error;
use std::ffi::{CStr, CString};
use std::fs::File;
use std::os::raw::c_char;
use std::ptr::addr_of_mut;
use std::{ptr, slice};

static BIN_DATA: &[u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/assets/scene.bin"));

/*
static SIM_SETTINGS: IPLSimulationSettings = IPLSimulationSettings {
    sceneType: IPLSceneType::IPL_SCENETYPE_PHONON,
    numRays: 2048,
    numDiffuseSamples: 512,
    numBounces: 16,
    irDuration: 1.5,
    ambisonicsOrder: 2,
    maxConvolutionSources: 4,
};

static DEVICE_FILTER: IPLComputeDeviceFilter = IPLComputeDeviceFilter {
    type_: IPLComputeDeviceType::IPL_COMPUTEDEVICE_CPU,
    requiresTrueAudioNext: IPLbool::IPL_FALSE,
    minReservableCUs: 0,
    maxCUsToReserve: 32,
};
*/

/*
pub struct IPLContextSettings {
    #[doc = " The API version used by the caller. Context creation will fail if `phonon.dll` does not implement a"]
    #[doc = "compatible version of the API. Typically, this should be set to `STEAMAUDIO_VERSION`."]
    pub version: IPLuint32,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function to record log messages generated by"]
    #[doc = "certain operations."]
    pub logCallback: IPLLogFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to allocate"]
    #[doc = "memory."]
    pub allocateCallback: IPLAllocateFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to free memory."]
    pub freeCallback: IPLFreeFunction,
    #[doc = " The maximum SIMD instruction set level that Steam Audio should use. Steam Audio automatically"]
    #[doc = "chooses the best instruction set to use based on the user's CPU, but you can prevent it from"]
    #[doc = "using certain newer instruction sets using this parameter. For example, with some workloads,"]
    #[doc = "AVX512 instructions consume enough power that the CPU clock speed will be throttled, resulting"]
    #[doc = "in lower performance than expected. If you observe this in your application, set this"]
    #[doc = "parameter to `IPL_SIMDLEVEL_AVX2` or lower."]
    pub simdLevel: IPLSIMDLevel,
}
*/

unsafe extern "C" fn log_callback(level: IPLLogLevel, message: *const ::std::os::raw::c_char) {
    let c_str: &CStr = CStr::from_ptr(message);
    let str = c_str.to_str().unwrap();
    eprintln!("{:?}: {}", level, str);
}

struct IPLAudioBufferIterator {
    buffer: IPLAudioBuffer,
    frames: usize,
}

impl Iterator for IPLAudioBufferIterator {
    type Item = ();
    fn next(&mut self) -> Option<Self::Item> {
        if self.frames > 0 {
            unsafe {
                self.buffer.data = self.buffer.data.offset(self.buffer.numSamples as isize);
            }

            self.frames -= 1;
            Some(())
        } else {
            None
        }
    }
}

fn from_pcm_data(settings: IPLAudioSettings, mut data: Vec<f32>) -> Result<(usize, IPLAudioBuffer), Box<dyn Error>> {
    let frames = data.len() / settings.frameSize as usize;
    let mut outer = vec![data.as_mut_ptr()];

    let buffer = IPLAudioBuffer {
        numChannels: 1,
        numSamples: settings.frameSize,
        data: outer.as_mut_ptr(),
    };

    std::mem::forget(buffer.data);
    Ok((frames, buffer))
}

fn get_audio() -> Result<Vec<f32>, Box<dyn Error>> {
    let file = File::open("examples/audio/eduardo.ogg")?;
    let mut stream_reader = OggStreamReader::new(file)?;
    assert_eq!(stream_reader.ident_hdr.audio_channels, 1);

    let mut concatted = Vec::new();
    while let Some(packet) = stream_reader.read_dec_packet_generic::<Vec<Vec<f32>>>()? {
        concatted.extend(packet[0].clone());
    }

    Ok(concatted)
}

fn main() {
    let mut context = unsafe {
        let mut context = ptr::null_mut();
        let mut settings = IPLContextSettings {
            version: STEAMAUDIO_VERSION_MAJOR << 16
                | STEAMAUDIO_VERSION_MINOR << 8
                | STEAMAUDIO_VERSION_PATCH,
            logCallback: Some(log_callback),
            allocateCallback: None,
            simdLevel: IPLSIMDLevel::IPL_SIMDLEVEL_AVX512,
            freeCallback: None,
        };
        assert_eq!(
            IPLerror::IPL_STATUS_SUCCESS,
            iplContextCreate(&mut settings, &mut context)
        );
        context
    };

    println!("{:?}", context);

    let mut audio_settings = IPLAudioSettings {
        samplingRate: 44100,
        frameSize: 1024,
    };

    let file = CString::new("").unwrap();
    let hrtf = unsafe {
        let mut hrtf = ptr::null_mut();
        let mut hrtf_settings = IPLHRTFSettings {
            type_: IPLHRTFType::IPL_HRTFTYPE_DEFAULT,
            sofaFileName: file.as_ptr() as *const c_char,
        };

        println!("{:?}", hrtf);
        println!("{:?}", hrtf_settings);
        println!("{:?}", audio_settings);
        dbg!(context);
        dbg!(*context);
        assert_eq!(
            IPLerror::IPL_STATUS_SUCCESS,
            iplHRTFCreate(context, &mut audio_settings, &mut hrtf_settings, &mut hrtf,)
        );
        hrtf
    };

    dbg!(hrtf);

    let mut audio_buffer = get_audio().unwrap();
    let (frames, mut input_buffer) = from_pcm_data(audio_settings, audio_buffer).unwrap();

    {
        let mut effect_settings = IPLBinauralEffectSettings { hrtf: hrtf };

        let mut binaural = unsafe {
            let mut effect = ptr::null_mut();
            assert_eq!(
                IPLerror::IPL_STATUS_SUCCESS,
                iplBinauralEffectCreate(
                    context,
                    &mut audio_settings,
                    &mut effect_settings,
                    &mut effect
                )
            );
            effect
        };

        let mut output_buffer = IPLAudioBuffer {
            numChannels: 2,
            numSamples: audio_settings.frameSize,
            data: ptr::null_mut(),
        };

        unsafe {
            assert_eq!(
                IPLerror::IPL_STATUS_SUCCESS,
                iplAudioBufferAllocate(context, 2, audio_settings.frameSize, &mut output_buffer)
            );
        }

        let mut effect_params = IPLBinauralEffectParams {
            direction: IPLVector3 {
                x: 1.0,
                y: 1.0,
                z: 1.0,
            },
            hrtf: hrtf,
            interpolation: IPLHRTFInterpolation::IPL_HRTFINTERPOLATION_BILINEAR,
            spatialBlend: 1.0,
        };

        let mut output_audio = Vec::new();

        dbg!(effect_params);
        dbg!(binaural);
        dbg!(input_buffer);
        dbg!(output_buffer);

        for frame in 0..frames - 1 {
            println!("{:?}", frame);
            dbg!();

            let mut output_audio_frame: Vec<f32> = vec![0.0; (2 * audio_settings.frameSize) as usize];
            dbg!();
            unsafe {
            dbg!();
                iplBinauralEffectApply(binaural, &mut effect_params, &mut input_buffer, &mut output_buffer);
            dbg!();
                iplAudioBufferInterleave(context, &mut output_buffer, output_audio_frame.as_mut_ptr());
            dbg!();
            }

            dbg!();
            output_audio.extend(output_audio_frame.clone());
            dbg!();

            unsafe {
                input_buffer.data = input_buffer.data.offset(audio_settings.frameSize as isize);
            }
            dbg!();
        }
    }

    let effect_settings = IPLAmbisonicsEncodeEffectSettings { maxOrder: 2 };

    /*
    let mut device = unsafe {
        let mut device = ptr::null_mut();
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateComputeDevice(context, DEVICE_FILTER, &mut device));
        device
    };

    let mut scene = unsafe {
        let mut scene: IPLhandle = ptr::null_mut();
        let mut mesh: IPLhandle = ptr::null_mut();

        const NUM_TRIS: IPLint32 = 28;
        const NUM_VERTS: IPLint32 = 48;

        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateScene(context, device, SIM_SETTINGS, 1, &mut scene));
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateStaticMesh(scene, NUM_VERTS, NUM_TRIS, &mut mesh));

        let tris: &mut [IPLTriangle] = slice::from_raw_parts_mut(BIN_DATA.as_ptr() as _, 336);
        let vert: &mut [IPLVector3] = slice::from_raw_parts_mut(BIN_DATA.as_ptr().offset(336) as _, 576);

        iplSetStaticMeshVertices(scene, mesh, vert.as_mut_ptr());
        iplSetStaticMeshTriangles(scene, mesh, tris.as_mut_ptr());

        iplFinalizeScene(scene, None);
        scene
    };

    unsafe {
        let file = CString::new("scene/scene.obj").unwrap();
        iplDumpSceneToObjFile(scene, file.into_raw());
    }

    let mut env = unsafe {
        let mut env = ptr::null_mut();
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateEnvironment(context, device, SIM_SETTINGS, scene, ptr::null_mut(), &mut env));
        env
    };

    eprintln!("context={:?}", context);
    eprintln!("device={:?}", device);
    eprintln!("scene={:?}", scene);
    eprintln!("env={:?}", env);
    */

    unsafe {
        /*
        iplDestroyEnvironment(&mut env);
        iplDestroyScene(&mut scene);
        iplDestroyComputeDevice(&mut device);
        iplDestroyContext(&mut context);
        iplCleanup();
        */

        iplContextRelease(&mut context);
    }
}
