#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
extern crate steam_audio;
extern crate gl;
extern crate glfw;

use steam_audio::ffi::*;

use std::ptr::addr_of_mut;
use std::{ptr, slice};
use std::ffi::CString;
            
static BIN_DATA: &[u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/assets/scene.bin"));

/*
static SIM_SETTINGS: IPLSimulationSettings = IPLSimulationSettings {
    sceneType: IPLSceneType::IPL_SCENETYPE_PHONON,
    numRays: 2048,
    numDiffuseSamples: 512,
    numBounces: 16,
    irDuration: 1.5,
    ambisonicsOrder: 2,
    maxConvolutionSources: 4,
};

static DEVICE_FILTER: IPLComputeDeviceFilter = IPLComputeDeviceFilter {
    type_: IPLComputeDeviceType::IPL_COMPUTEDEVICE_CPU,
    requiresTrueAudioNext: IPLbool::IPL_FALSE,
    minReservableCUs: 0,
    maxCUsToReserve: 32,
};
*/


/*
pub struct IPLContextSettings {
    #[doc = " The API version used by the caller. Context creation will fail if `phonon.dll` does not implement a"]
    #[doc = "compatible version of the API. Typically, this should be set to `STEAMAUDIO_VERSION`."]
    pub version: IPLuint32,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function to record log messages generated by"]
    #[doc = "certain operations."]
    pub logCallback: IPLLogFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to allocate"]
    #[doc = "memory."]
    pub allocateCallback: IPLAllocateFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to free memory."]
    pub freeCallback: IPLFreeFunction,
    #[doc = " The maximum SIMD instruction set level that Steam Audio should use. Steam Audio automatically"]
    #[doc = "chooses the best instruction set to use based on the user's CPU, but you can prevent it from"]
    #[doc = "using certain newer instruction sets using this parameter. For example, with some workloads,"]
    #[doc = "AVX512 instructions consume enough power that the CPU clock speed will be throttled, resulting"]
    #[doc = "in lower performance than expected. If you observe this in your application, set this"]
    #[doc = "parameter to `IPL_SIMDLEVEL_AVX2` or lower."]
    pub simdLevel: IPLSIMDLevel,
}
*/

fn main() {
    let mut context = unsafe {
        let context: *mut IPLContext = ptr::null_mut();
        let settings = IPLContextSettings {
            version: STEAMAUDIO_VERSION_MAJOR << 16 | STEAMAUDIO_VERSION_MINOR << 8 | STEAMAUDIO_VERSION_PATCH,
            logCallback: None,
            allocateCallback: None,
            simdLevel: IPLSIMDLevel::IPL_SIMDLEVEL_AVX512,
            freeCallback: None,
        };
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplContextCreate(&settings as *const _ as *mut _, &context as *const _ as *mut _));
        context
    };

    println!("{:?}", context);

    let mut audio_settings = IPLAudioSettings {
        samplingRate: 44100,
        frameSize: 1024,
    };

    let hrtf = unsafe {
        let mut hrtf: *mut IPLHRTF = ptr::null_mut();
        let mut hrtf_settings = IPLHRTFSettings {
            type_: IPLHRTFType::IPL_HRTFTYPE_DEFAULT,
            sofaFileName: ptr::null(),
        };

        dbg!();
        dbg!(*context);
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplHRTFCreate(*context, &audio_settings as *const _ as *mut _, &hrtf_settings as *const _ as *mut _, &hrtf as *const _ as *mut _));
        dbg!();
    };

    println!("{:?}", hrtf);

    /*
    let mut device = unsafe {
        let mut device = ptr::null_mut();
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateComputeDevice(context, DEVICE_FILTER, &mut device));
        device
    };

    let mut scene = unsafe {
        let mut scene: IPLhandle = ptr::null_mut();
        let mut mesh: IPLhandle = ptr::null_mut();

        const NUM_TRIS: IPLint32 = 28;
        const NUM_VERTS: IPLint32 = 48;

        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateScene(context, device, SIM_SETTINGS, 1, &mut scene));
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateStaticMesh(scene, NUM_VERTS, NUM_TRIS, &mut mesh));

        let tris: &mut [IPLTriangle] = slice::from_raw_parts_mut(BIN_DATA.as_ptr() as _, 336);
        let vert: &mut [IPLVector3] = slice::from_raw_parts_mut(BIN_DATA.as_ptr().offset(336) as _, 576);

        iplSetStaticMeshVertices(scene, mesh, vert.as_mut_ptr());
        iplSetStaticMeshTriangles(scene, mesh, tris.as_mut_ptr());

        iplFinalizeScene(scene, None);
        scene
    };

    unsafe {
        let file = CString::new("scene/scene.obj").unwrap();
        iplDumpSceneToObjFile(scene, file.into_raw());
    }

    let mut env = unsafe {
        let mut env = ptr::null_mut();
        assert_eq!(IPLerror::IPL_STATUS_SUCCESS, iplCreateEnvironment(context, device, SIM_SETTINGS, scene, ptr::null_mut(), &mut env));
        env
    };

    eprintln!("context={:?}", context);
    eprintln!("device={:?}", device);
    eprintln!("scene={:?}", scene);
    eprintln!("env={:?}", env);
    
    unsafe {
        iplDestroyEnvironment(&mut env);
        iplDestroyScene(&mut scene);
        iplDestroyComputeDevice(&mut device);
        iplDestroyContext(&mut context);
        iplCleanup();
    }
    */
}
